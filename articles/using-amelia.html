<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Using Amelia • Amelia</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Using Amelia">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">Amelia</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.8.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/intro-mi.html">Introduction to Multiple Imputation</a>
    </li>
    <li>
      <a href="../articles/using-amelia.html">Using Amelia</a>
    </li>
    <li>
      <a href="../articles/diagnostics.html">Multiple Imputation Diagnostics</a>
    </li>
    <li>
      <a href="../articles/ameliaview.html">AmeliaView GUI Guide</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Using Amelia</h1>
            
            <h4 data-toc-skip class="date">2024-11-07</h4>
      

      <div class="hidden name"><code>using-amelia.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="data">Data<a class="anchor" aria-label="anchor" href="#data"></a>
</h2>
<p>We now demonstrate how to use Amelia using data from <span class="citation">Milner and Kubota (<a href="#ref-MilKub05">2005</a>)</span> which studies the effect of
democracy on trade policy. For the purposes of this user’s guide, we
will use a subset restricted to nine developing countries in Asia from
1980 to 1999<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. This dataset includes 9 variables:</p>
<table class="table">
<thead><tr class="header">
<th align="left">Variable</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><code>year</code></td>
<td align="left">year</td>
</tr>
<tr class="even">
<td align="left"><code>country</code></td>
<td align="left">country</td>
</tr>
<tr class="odd">
<td align="left"><code>tariff</code></td>
<td align="left">average tariff rates</td>
</tr>
<tr class="even">
<td align="left"><code>polity</code></td>
<td align="left">Polity IV Score<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>
</td>
</tr>
<tr class="odd">
<td align="left"><code>pop</code></td>
<td align="left">total population</td>
</tr>
<tr class="even">
<td align="left"><code>gdp.pc</code></td>
<td align="left">gross domestic product per capita</td>
</tr>
<tr class="odd">
<td align="left"><code>intresmi</code></td>
<td align="left">gross international reserves</td>
</tr>
<tr class="even">
<td align="left"><code>signed</code></td>
<td align="left">dummy variable if signed an IMF agreement that
year</td>
</tr>
<tr class="odd">
<td align="left"><code>fivop</code></td>
<td align="left">measure of financial openness</td>
</tr>
<tr class="even">
<td align="left"><code>usheg</code></td>
<td align="left">measure of US hegemony<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>
</td>
</tr>
</tbody>
</table>
<p>These variables correspond to the variables used in the analysis
model of <span class="citation">Milner and Kubota (<a href="#ref-MilKub05">2005</a>)</span> in table 2.</p>
<p>We first load the Amelia and the data:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://gking.harvard.edu/amelia" class="external-link">Amelia</a></span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Loading required package: Rcpp</span></span></code></pre>
<pre><code><span><span class="co">## ## </span></span>
<span><span class="co">## ## Amelia II: Multiple Imputation</span></span>
<span><span class="co">## ## (Version 1.8.2, built: 2024-04-10)</span></span>
<span><span class="co">## ## Copyright (C) 2005-2024 James Honaker, Gary King and Matthew Blackwell</span></span>
<span><span class="co">## ## Refer to http://gking.harvard.edu/amelia/ for more information</span></span>
<span><span class="co">## ##</span></span></code></pre>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">freetrade</span><span class="op">)</span></span></code></pre></div>
<p>We can check the summary statistics of the data to see that there is
missingness on many of the variables:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">freetrade</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##       year        country              tariff          polity    </span></span>
<span><span class="co">##  Min.   :1981   Length:171         Min.   :  7.1   Min.   :-8.0  </span></span>
<span><span class="co">##  1st Qu.:1985   Class :character   1st Qu.: 16.3   1st Qu.:-2.0  </span></span>
<span><span class="co">##  Median :1990   Mode  :character   Median : 25.2   Median : 5.0  </span></span>
<span><span class="co">##  Mean   :1990                      Mean   : 31.6   Mean   : 2.9  </span></span>
<span><span class="co">##  3rd Qu.:1995                      3rd Qu.: 40.8   3rd Qu.: 8.0  </span></span>
<span><span class="co">##  Max.   :1999                      Max.   :100.0   Max.   : 9.0  </span></span>
<span><span class="co">##                                    NA's   :58      NA's   :2     </span></span>
<span><span class="co">##       pop               gdp.pc         intresmi         signed     </span></span>
<span><span class="co">##  Min.   :1.41e+07   Min.   :  150   Min.   :0.904   Min.   :0.000  </span></span>
<span><span class="co">##  1st Qu.:1.97e+07   1st Qu.:  420   1st Qu.:2.223   1st Qu.:0.000  </span></span>
<span><span class="co">##  Median :5.28e+07   Median :  814   Median :3.182   Median :0.000  </span></span>
<span><span class="co">##  Mean   :1.50e+08   Mean   : 1867   Mean   :3.375   Mean   :0.155  </span></span>
<span><span class="co">##  3rd Qu.:1.21e+08   3rd Qu.: 2463   3rd Qu.:4.406   3rd Qu.:0.000  </span></span>
<span><span class="co">##  Max.   :9.98e+08   Max.   :12086   Max.   :7.935   Max.   :1.000  </span></span>
<span><span class="co">##                                     NA's   :13      NA's   :3      </span></span>
<span><span class="co">##      fiveop         usheg      </span></span>
<span><span class="co">##  Min.   :12.3   Min.   :0.256  </span></span>
<span><span class="co">##  1st Qu.:12.5   1st Qu.:0.262  </span></span>
<span><span class="co">##  Median :12.6   Median :0.276  </span></span>
<span><span class="co">##  Mean   :12.7   Mean   :0.276  </span></span>
<span><span class="co">##  3rd Qu.:13.2   3rd Qu.:0.289  </span></span>
<span><span class="co">##  Max.   :13.2   Max.   :0.308  </span></span>
<span><span class="co">##  NA's   :18</span></span></code></pre>
<p>In the presence of missing data, most statistical packages use
<em>listwise deletion</em>, which removes any row that contains a
missing value from the analysis. Using the base model of <span class="citation">Milner and Kubota (<a href="#ref-MilKub05">2005</a>)</span> Table 2, we run a simple linear
model in R, which uses listwise deletion:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">tariff</span> <span class="op">~</span> <span class="va">polity</span> <span class="op">+</span> <span class="va">pop</span> <span class="op">+</span> <span class="va">gdp.pc</span> <span class="op">+</span> <span class="va">year</span> <span class="op">+</span> <span class="va">country</span>,</span>
<span>          data <span class="op">=</span> <span class="va">freetrade</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## lm(formula = tariff ~ polity + pop + gdp.pc + year + country, </span></span>
<span><span class="co">##     data = freetrade)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Residuals:</span></span>
<span><span class="co">##     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">## -30.764  -3.259   0.087   2.598  18.310 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Coefficients:</span></span>
<span><span class="co">##                     Estimate Std. Error t value Pr(&gt;|t|)</span></span>
<span><span class="co">## (Intercept)         1.97e+03   4.02e+02    4.91  3.6e-06</span></span>
<span><span class="co">## polity             -1.37e-01   1.82e-01   -0.75     0.45</span></span>
<span><span class="co">## pop                -2.02e-07   2.54e-08   -7.95  3.2e-12</span></span>
<span><span class="co">## gdp.pc              6.10e-04   7.44e-04    0.82     0.41</span></span>
<span><span class="co">## year               -8.71e-01   2.08e-01   -4.18  6.4e-05</span></span>
<span><span class="co">## countryIndonesia   -1.82e+02   1.86e+01   -9.82  3.0e-16</span></span>
<span><span class="co">## countryKorea       -2.20e+02   2.08e+01  -10.61  &lt; 2e-16</span></span>
<span><span class="co">## countryMalaysia    -2.25e+02   2.17e+01  -10.34  &lt; 2e-16</span></span>
<span><span class="co">## countryNepal       -2.16e+02   2.25e+01   -9.63  7.7e-16</span></span>
<span><span class="co">## countryPakistan    -1.55e+02   1.98e+01   -7.84  5.6e-12</span></span>
<span><span class="co">## countryPhilippines -2.04e+02   2.09e+01   -9.77  3.7e-16</span></span>
<span><span class="co">## countrySriLanka    -2.09e+02   2.21e+01   -9.46  1.8e-15</span></span>
<span><span class="co">## countryThailand    -1.96e+02   2.10e+01   -9.36  3.0e-15</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Residual standard error: 6.22 on 98 degrees of freedom</span></span>
<span><span class="co">##   (60 observations deleted due to missingness)</span></span>
<span><span class="co">## Multiple R-squared:  0.925,  Adjusted R-squared:  0.915 </span></span>
<span><span class="co">## F-statistic:  100 on 12 and 98 DF,  p-value: &lt;2e-16</span></span></code></pre>
<p>Note that 60 of the 171 original observations are deleted due to
missingness. These observations, however, are partially observed, and
contain valuable information about the relationships between those
variables which are present in the partially completed observations.
Multiple imputation will help us retrieve that information and make
better, more efficient, inferences.</p>
</div>
<div class="section level2">
<h2 id="multiple-imputation">Multiple Imputation<a class="anchor" aria-label="anchor" href="#multiple-imputation"></a>
</h2>
<p>When performing multiple imputation, the first step is to identify
the variables to include in the imputation model. It is crucial to
include at least as much information as will be used in the analysis
model. That is, any variable that will be in the analysis model should
also be in the imputation model. This includes any transformations or
interactions of variables that will appear in the analysis model.</p>
<p>In fact, it is often useful to add more information to the imputation
model than will be present when the analysis is run. Since imputation is
predictive, any variables that would increase predictive power should be
included in the model, even if including them in the analysis model
would produce bias in estimating a causal effect (such as for
post-treatment variables) or collinearity would preclude determining
which variable had a relationship with the dependent variable (such as
including multiple alternate measures of GDP). In our case, we include
all the variables in <code>freetrade</code> in the imputation model,
even though our analysis model focuses on <code>polity</code>,
<code>pop</code> and <code>gdp.pc</code>. We’re not incorporating time
or spatial data yet, but we do below.</p>
<p>To create multiple imputations in Amelia, we can simply run</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, m <span class="op">=</span> <span class="fl">5</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## -- Imputation 1 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 2 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 3 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 4 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 5 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18</span></span></code></pre>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Amelia output with 5 imputed datasets.</span></span>
<span><span class="co">## Return code:  1 </span></span>
<span><span class="co">## Message:  Normal EM convergence. </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Chain Lengths:</span></span>
<span><span class="co">## --------------</span></span>
<span><span class="co">## Imputation 1:  14</span></span>
<span><span class="co">## Imputation 2:  14</span></span>
<span><span class="co">## Imputation 3:  16</span></span>
<span><span class="co">## Imputation 4:  15</span></span>
<span><span class="co">## Imputation 5:  18</span></span></code></pre>
<p>Note that our example dataset is deliberately small both in variables
and in cross-sectional elements. Typical datasets may often have
hundreds or possibly a couple thousand steps to the EM algorithm. Long
chains should remind the analyst to consider whether transformations of
the variables would more closely fit the multivariate normal assumptions
of the model (correct but omitted transformations will shorten the
number of steps and improve the fit of the imputations), but do not
necessarily denote problems with the imputation model.</p>
<p>The output gives some information about how the algorithm ran. Each
of the imputed datasets is now in the list
<code>a.out$imputations</code>. Thus, we could plot a histogram of the
<code>tariff</code> variable from the 3rd imputation,</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">a.out</span><span class="op">$</span><span class="va">imputations</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">tariff</span>, col <span class="op">=</span> <span class="st">"grey"</span>, border <span class="op">=</span> <span class="st">"white"</span><span class="op">)</span></span></code></pre></div>
<p><img src="using-amelia_files/figure-html/unnamed-chunk-1-1.png" width="480" style="display: block; margin: auto;"></p>
<div class="section level3">
<h3 id="saving-imputed-datasets">Saving imputed datasets<a class="anchor" aria-label="anchor" href="#saving-imputed-datasets"></a>
</h3>
<p>If you need to save your imputed datasets, one direct method is to
save the output list from <code>amelia</code>,</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/save.html" class="external-link">save</a></span><span class="op">(</span><span class="va">a.out</span>, file <span class="op">=</span> <span class="st">"imputations.RData"</span><span class="op">)</span></span></code></pre></div>
<p>As in the previous example, the ith imputed datasets can be retrieved
from this list as <code>a.out$imputations[[i]]</code>.</p>
<p>In addition, you can save each of the imputed datasets to its own
file using the <code><a href="../reference/write.amelia.html">write.amelia()</a></code> command,</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/write.amelia.html">write.amelia</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">a.out</span>, file.stem <span class="op">=</span> <span class="st">"outdata"</span><span class="op">)</span></span></code></pre></div>
<p>This will create one comma-separated value file for each imputed
dataset in the following manner:</p>
<pre><code><span><span class="va">outdata1.csv</span></span>
<span><span class="va">outdata2.csv</span></span>
<span><span class="va">outdata3.csv</span></span>
<span><span class="va">outdata4.csv</span></span>
<span><span class="va">outdata5.csv</span></span></code></pre>
<p>The <code>write.amelia</code> function can also save files in
tab-delimited and Stata (<code>.dta</code>) file formats. For instance,
to save Stata files, simply change the <code>format</code> argument to
<code>"dta"</code>,</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/write.amelia.html">write.amelia</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">a.out</span>, file.stem <span class="op">=</span> <span class="st">"outdata"</span>, format <span class="op">=</span> <span class="st">"dta"</span><span class="op">)</span></span></code></pre></div>
<p>Additionally, <code><a href="../reference/write.amelia.html">write.amelia()</a></code> can create a “stacked”
version of the imputed dataset which stacks each imputed dataset on top
of one another. This can be done by setting the argument to
<code>FALSE</code>. The resulting matrix is of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>⋅</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">(N \cdot m) \times p</annotation></semantics></math>
if the original dataset is excluded (<code>orig.data = FALSE</code>) and
of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">(N \cdot (m+1))\times p</annotation></semantics></math>
if it is included (<code>orig.data = TRUE</code>). The stacked dataset
will include a variable (set with <code>impvar</code>) that indicates to
which imputed dataset the observation belongs.</p>
</div>
</div>
<div class="section level2">
<h2 id="combining-multiple-calls-to-amelia">Combining multiple calls to <code>amelia()</code><a class="anchor" aria-label="anchor" href="#combining-multiple-calls-to-amelia"></a>
</h2>
<p>The EMB algorithm is what computer scientists call <em>embarrassingly
parallel</em>, meaning that it is simple to separate each imputation
into parallel processes. With Amelia it is simple to run subsets of the
imputations on different machines and then combine them after the
imputation for use in analysis model. This allows for a huge increase in
the speed of the algorithm.</p>
<p>Output lists from different Amelia runs can be combined together into
a new list. For instance, suppose that we wanted to add another ten
imputed datasets to our earlier call to <code><a href="../reference/amelia.html">amelia()</a></code>. First,
run the function to get these additional imputations,</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out.more</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, m <span class="op">=</span> <span class="fl">10</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, p2s <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">a.out.more</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Amelia output with 10 imputed datasets.</span></span>
<span><span class="co">## Return code:  1 </span></span>
<span><span class="co">## Message:  Normal EM convergence. </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Chain Lengths:</span></span>
<span><span class="co">## --------------</span></span>
<span><span class="co">## Imputation 1:  18</span></span>
<span><span class="co">## Imputation 2:  16</span></span>
<span><span class="co">## Imputation 3:  14</span></span>
<span><span class="co">## Imputation 4:  17</span></span>
<span><span class="co">## Imputation 5:  12</span></span>
<span><span class="co">## Imputation 6:  21</span></span>
<span><span class="co">## Imputation 7:  8</span></span>
<span><span class="co">## Imputation 8:  14</span></span>
<span><span class="co">## Imputation 9:  20</span></span>
<span><span class="co">## Imputation 10:  9</span></span></code></pre>
<p>then combine this output with our original output using the
<code><a href="../reference/ameliabind.html">ameliabind()</a></code> function,</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out.more</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ameliabind.html">ameliabind</a></span><span class="op">(</span><span class="va">a.out</span>, <span class="va">a.out.more</span><span class="op">)</span></span>
<span><span class="va">a.out.more</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Amelia output with 15 imputed datasets.</span></span>
<span><span class="co">## Return code:  1 </span></span>
<span><span class="co">## Message:  Normal EM convergence </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Chain Lengths:</span></span>
<span><span class="co">## --------------</span></span>
<span><span class="co">## Imputation 1:  14</span></span>
<span><span class="co">## Imputation 2:  14</span></span>
<span><span class="co">## Imputation 3:  16</span></span>
<span><span class="co">## Imputation 4:  15</span></span>
<span><span class="co">## Imputation 5:  18</span></span>
<span><span class="co">## Imputation 6:  18</span></span>
<span><span class="co">## Imputation 7:  16</span></span>
<span><span class="co">## Imputation 8:  14</span></span>
<span><span class="co">## Imputation 9:  17</span></span>
<span><span class="co">## Imputation 10:  12</span></span>
<span><span class="co">## Imputation 11:  21</span></span>
<span><span class="co">## Imputation 12:  8</span></span>
<span><span class="co">## Imputation 13:  14</span></span>
<span><span class="co">## Imputation 14:  20</span></span>
<span><span class="co">## Imputation 15:  9</span></span></code></pre>
<p>This function binds the two outputs into the same output so that you
can pass the combined imputations easily to analysis models and
diagnostics. Note that <code>a.out.more</code> now has a total of 15
imputations.</p>
<p>A simple way to execute a parallel processing scheme with Amelia
would be to run <code><a href="../reference/amelia.html">amelia()</a></code> with <code>m</code> set to 1 on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
different machines or processors, save each output using the
<code><a href="https://rdrr.io/r/base/save.html" class="external-link">save()</a></code> function, load them all on the same R session using
<code><a href="https://rdrr.io/r/base/load.html" class="external-link">load()</a></code> command and then combine them using
<code><a href="../reference/ameliabind.html">ameliabind()</a></code>. In order to do this, however, make sure to
name each of the outputs a different name so that they do not overwrite
each other when loading into the same R session. Also, some parallel
environments will dump all generated files into a common directory,
where they may overwrite each other. If it is convenient in a parallel
environment to run a large number of <code><a href="../reference/amelia.html">amelia()</a></code> calls from a
single piece of code, one useful way to avoid overwriting is to create
the <code>file.stem</code> with a random suffix. For example:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">b</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span>, min <span class="op">=</span> <span class="fl">1111</span>, max <span class="op">=</span> <span class="fl">9999</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">random.name</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"am"</span>, <span class="va">b</span>, sep <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span>
<span><span class="va">amelia</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/write.amelia.html">write.amelia</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">a.out</span>, file.stem <span class="op">=</span> <span class="va">random.name</span><span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="screen-output">Screen output<a class="anchor" aria-label="anchor" href="#screen-output"></a>
</h3>
<p>Screen output can be adjusted with the “print to screen” argument,
<code>p2s</code>. At a value of 0, no screen printing will occur. This
may be useful in large jobs or simulations where a very large number of
imputation models may be required. The default value of 1, lists each
bootstrap, and displays the number of iterations required to reach
convergence in that bootstrapped dataset. The value of 2 gives more
thorough screen output, including, at each iteration, the number of
parameters that have significantly changed since the last iteration.
This may be useful when the EM chain length is very long, as it can
provide an intuition for many parameters still need to converge in the
EM chain, and a sense of the time remaining. However, it is worth noting
that the last several parameters can often take a significant fraction
of the total number of iterations to converge. Setting <code>p2s</code>
to 2 will also generate information on how EM algorithm is behaving,
such as a <code>!</code> when the current estimated complete data
covariance matrix is not invertible and a <code>*</code> when the
likelihood has not monotonically increased in that step. Having many of
these two symbols in the screen output is an indication of a problematic
imputation model. Problems of non-invertible matrices often mean that
current guess for the covariance matrix is singular. This is a sign that
there may be two highly correlated variables in the model. One way to
resolve is to use a ridge prior (see @ref(sec_prior)).</p>
<p>An example of the output when <code>p2s</code> is 2 would be</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out.p2s</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, m <span class="op">=</span> <span class="fl">1</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, p2s <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## amelia starting</span></span>
<span><span class="co">## beginning prep functions</span></span>
<span><span class="co">## Variables used:  tariff polity pop gdp.pc intresmi signed fiveop usheg </span></span>
<span><span class="co">## running bootstrap</span></span>
<span><span class="co">## -- Imputation 1 --</span></span>
<span><span class="co">## setting up EM chain indicies</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1(44)  2(33)  3(27)  4(21)  5(22)  6(22)  7(19)  8(18)  9(14) 10(8) 11(6) 12(2) 13(0)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##  saving and cleaning</span></span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="sec:parallel">Parallel Imputation<a class="anchor" aria-label="anchor" href="#sec:parallel"></a>
</h2>
<p>Each imputation in the above EMB algorithm is completely independent
of any other imputation, a property called embarrassingly parallel. This
type of approach can take advantage of the multiple-core infrastructure
of modern CPUs. Each core in a multi-core processor can execute
independent operations in parallel. Amelia can utilize this parallel
processing internally via the <code>parallel</code> and the
<code>ncpus</code> arguments. The <code>parallel</code> argument sets
the parallel processing backend, either with <code>"multicore"</code> or
<code>"snow"</code> (or <code>"no"</code> for no parallel processing).
The <code>"multicore"</code> backend is not available on Windows
systems, but tends to be quicker at parallel processing. On a Windows
system, the <code>"snow"</code> backend provides parallel processing
through a cluster of worker processes across the CPUs. You can set the
default for this argument using the <code>"amelia.parallel"</code>
option. This allows you to run Amelia in parallel as the default for an
entire R session without setting arguments in the <code><a href="../reference/amelia.html">amelia()</a></code>
call.</p>
<p>For each of the parallel backends, Amelia requires a number of CPUs
to use in parallel. This can be set using the <code>ncpus</code>
argument. It can be higher than the number of physical cores in the
system if hyperthreading or other technologies are available. You can
use the <code><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">parallel::detectCores()</a></code> function to determine how
many cores are available on your machine. The default for this argument
can be set using the <code>"amelia.ncpus"</code> option.</p>
<p>On Unix-alike systems (such as macOS and Linux distributions), the
<code>"multicore"</code> backend automatically sets up and stops the
parallel workers by forking the process. On Windows, the
<code>"snow"</code> backend requires more attention. Amelia will attempt
to create a parallel cluster of worker processes (since Windows systems
cannot fork a process) and will stop this cluster after the imputations
are complete. Alternatively, Amelia also has a <code>cl</code> argument,
which accepts a predefined cluster made using the
<code><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">parallel::makePSOCKcluster()</a></code>. For more information about
parallel processing in R, see the documentation for the
<code>parallel</code> package that ships along with R or the CRAN Task
View on <a href="https://cran.r-project.org/view=HighPerformanceComputing" class="external-link">Parallel
Computing with R</a></p>
</div>
<div class="section level2">
<h2 id="sec:trans">Improving Imputations via Transformations<a class="anchor" aria-label="anchor" href="#sec:trans"></a>
</h2>
<p>Social science data commonly includes variables that fail to fit to a
multivariate normal distribution. Indeed, numerous models have been
introduced specifically to deal with the problems they present. As it
turns out, much evidence in the literature <span class="citation">(discussed in <a href="#ref-KinHonJos01">King et al.
2001</a>)</span> indicates that the multivariate normal model used in
Amelia usually works well for the imputation stage even when discrete or
non-normal variables are included and when the analysis stage involves
these limited dependent variable models. Nevertheless, Amelia includes
some limited capacity to deal directly with ordinal and nominal
variables and to modify variables that require other transformations. In
general nominal and log transform variables should be declared to
Amelia, whereas ordinal (including dichotomous) variables often need not
be, as described below. (For harder cases, see <span class="citation">(<a href="#ref-Schafer97">Schafer 1997</a>)</span>, for
specialized MCMC-based imputation models for discrete variables.)</p>
<p>Although these transformations are taken internally on these
variables to better fit the data to the multivariate normal assumptions
of the imputation model, all the imputations that are created will be
returned in the original untransformed form of the data. If the user has
already performed transformations on their data (such as by taking a log
or square root prior to feeding the data to <code><a href="../reference/amelia.html">amelia()</a></code>) these
do not need to be declared, as that would result in the transformation
occurring <em>doubly</em> in the imputation model. The fully imputed
data sets that are returned will always be in the form of the original
data that is passed to the <code><a href="../reference/amelia.html">amelia()</a></code> routine.</p>
<div class="section level3">
<h3 id="sec:ord">Ordinal<a class="anchor" aria-label="anchor" href="#sec:ord"></a>
</h3>
<p>In much statistical research, researchers treat independent ordinal
(including dichotomous) variables as if they were really continuous. If
the analysis model to be employed is of this type, then nothing extra is
required of the of the imputation model. Users are advised to allow
Amelia to impute non-integer values for any missing data, and to use
these non-integer values in their analysis. Sometimes this makes sense,
and sometimes this defies intuition. One particular imputation of 2.35
for a missing value on a seven point scale carries the intuition that
the respondent is between a 2 and a 3 and most probably would have
responded 2 had the data been observed. This is easier to accept than an
imputation of 0.79 for a dichotomous variable where a zero represents a
male and a one represents a female respondent. However, in both cases
the non-integer imputations carry more information about the underlying
distribution than would be carried if we were to force the imputations
to be integers. Thus whenever the analysis model permits, missing
ordinal observations should be allowed to take on continuously valued
imputations.</p>
<p>In the <code>freetrade</code> data, one such ordinal variable is
<code>polity</code> which ranges from -10 (full autocracy) to 10 (full
democracy). If we tabulate this variable from one of the imputed
datasets,</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">a.out</span><span class="op">$</span><span class="va">imputations</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">polity</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##                -8 -7.45783715909671                -7                -6 </span></span>
<span><span class="co">##                 1                 1                22                 4 </span></span>
<span><span class="co">##                -5                -4                -2                -1 </span></span>
<span><span class="co">##                 7                 3                 9                 1 </span></span>
<span><span class="co">##                 2                 3                 4                 5 </span></span>
<span><span class="co">##                 7                 7                15                26 </span></span>
<span><span class="co">##                 6                 7                 8                 9 </span></span>
<span><span class="co">##                13                 5                36                13 </span></span>
<span><span class="co">##  9.78025479283451 </span></span>
<span><span class="co">##                 1</span></span></code></pre>
<p>we can see that there is one imputation between -4 and -3 and one
imputation between 6 and 7. Again, the interpretation of these values is
rather straightforward even if they are not strictly in the coding of
the original Polity data.</p>
<p>Often, however, analysis models require some variables to be strictly
ordinal, as for example, when the dependent variable will be modeled in
a logistical or Poisson regression. Imputations for variables set as
ordinal are created by taking the continuously valued imputation and
using an appropriately scaled version of this as the probability of
success in a binomial distribution. The draw from this binomial
distribution is then translated back into one of the ordinal
categories.</p>
<p>For our data we can simply add <code>polity</code> to the
<code>ords</code> argument:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, m <span class="op">=</span> <span class="fl">5</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, ords <span class="op">=</span></span>
<span>                 <span class="st">"polity"</span>, p2s <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">a.out1</span><span class="op">$</span><span class="va">imputations</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">polity</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## -8 -7 -6 -5 -4 -2 -1  2  3  4  5  6  7  8  9 </span></span>
<span><span class="co">##  1 22  4  8  3  9  1  7  7 15 26 13  5 36 14</span></span></code></pre>
<p>Now, we can see that all of the imputations fall into one of the
original polity categories.</p>
</div>
<div class="section level3">
<h3 id="sec:nom">Nominal<a class="anchor" aria-label="anchor" href="#sec:nom"></a>
</h3>
<p>Nominal variables<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> must be treated quite differently than
ordinal variables. Any multinomial variables in the data set (such as
religion coded 1 for Catholic, 2 for Jewish, and 3 for Protestant) must
be specified to Amelia. In our dataset, we have <code>signed</code>
which is 1 if a country signed an IMF agreement in that year and 0 if it
did not. Of course, our first imputation did not limit the imputations
to these two categories</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">a.out1</span><span class="op">$</span><span class="va">imputations</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">signed</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## -0.581727039334061 -0.417310204209806                  0  0.914087081006918 </span></span>
<span><span class="co">##                  1                  1                142                  1 </span></span>
<span><span class="co">##                  1 </span></span>
<span><span class="co">##                 26</span></span></code></pre>
<p>In order to fix this for a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-category
multinomial variable, Amelia will determine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
(as long as your data contain at least one value in each category), and
substitute $ p-1$ binary variables to specify each possible category.
These new
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math>
variables will be treated as the other variables in the multivariate
normal imputation method chosen, and receive continuous imputations.
These continuously valued imputations will then be appropriately scaled
into probabilities for each of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
possible categories, and one of these categories will be drawn, where
upon the original
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-category
multinomial variable will be reconstructed and returned to the user.
Thus all imputations will be appropriately multinomial.</p>
<p>For our data we can simply add <code>signed</code> to the
<code>noms</code> argument:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, m <span class="op">=</span> <span class="fl">5</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>,</span>
<span>                 noms <span class="op">=</span> <span class="st">"signed"</span>, p2s <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">a.out2</span><span class="op">$</span><span class="va">imputations</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">signed</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##   0   1 </span></span>
<span><span class="co">## 143  28</span></span></code></pre>
<p>Note that Amelia can only fit imputations into categories that exist
in the original data. Thus, if there was a third category of signed, say
2, that corresponded to a different kind of IMF agreement, but it never
occurred in the original data, Amelia could not match imputations to
it.</p>
<p>Since Amelia properly treats a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-category
multinomial variable as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math>
variables, one should understand the number of parameters that are
quickly accumulating if many multinomial variables are being used. If
the square of the number of real and constructed variables is large
relative to the number of observations, it is useful to use a ridge
prior as in section @ref(sec_prior).</p>
</div>
<div class="section level3">
<h3 id="sec:log">Natural log<a class="anchor" aria-label="anchor" href="#sec:log"></a>
</h3>
<p>If one of your variables is heavily skewed or has outliers that may
alter the imputation in an unwanted way, you can use a natural logarithm
transformation of that variable in order to normalize its distribution.
This transformed distribution helps Amelia to avoid imputing values that
depend too heavily on outlying data points. Log transformations are
common in expenditure and economic variables where we have strong
beliefs that the marginal relationship between two variables decreases
as we move across the range.</p>
<p>For instance, we can show the <code>tariff</code> variable clearly
has positive (or, right) skew while its natural log transformation has a
roughly normal distribution.</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">freetrade</span><span class="op">$</span><span class="va">tariff</span>, col<span class="op">=</span><span class="st">"grey"</span>, border<span class="op">=</span><span class="st">"white"</span><span class="op">)</span></span></code></pre></div>
<p><img src="using-amelia_files/figure-html/tarrif_hist-1.png" width="480" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">freetrade</span><span class="op">$</span><span class="va">tariff</span><span class="op">)</span>, col<span class="op">=</span><span class="st">"grey"</span>, border<span class="op">=</span><span class="st">"white"</span><span class="op">)</span></span></code></pre></div>
<p><img src="using-amelia_files/figure-html/tarrif_hist-2.png" width="480" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="sec:sqrt">Square root<a class="anchor" aria-label="anchor" href="#sec:sqrt"></a>
</h3>
<p>Event count data is often heavily skewed and has nonlinear
relationships with other variables. One common transformation to tailor
the linear model to count data is to take the square roots of the
counts. This is a transformation that can be set as an option in
Amelia.</p>
</div>
<div class="section level3">
<h3 id="sec:lgstc">Logistic<a class="anchor" aria-label="anchor" href="#sec:lgstc"></a>
</h3>
<p>Proportional data is sharply bounded between 0 and 1. A logistic
transformation is one possible option in Amelia to make the distribution
symmetric and relatively unbounded.</p>
</div>
</div>
<div class="section level2">
<h2 id="sec:idvars">Identification Variables<a class="anchor" aria-label="anchor" href="#sec:idvars"></a>
</h2>
<p>Datasets often contain identification variables, such as country
names, respondent numbers, or other identification numbers, codes or
abbreviations. Sometimes these are text and sometimes these are numeric.
Often it is not appropriate to include these variables in the imputation
model, but it is useful to have them remain in the imputed datasets
(However, there are models that would include the ID variables in the
imputation model, such as fixed effects model for data with repeated
observations of the same countries). Identification variables which are
not to be included in the imputation model can be identified with the
argument <code>idvars</code>. These variables will not be used in the
imputation model, but will be kept in the imputed datasets.</p>
<p>If the <code>year</code> and <code>country</code> contained no
information except labels, we could omit them from the imputation:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, idvars <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"year"</span>, <span class="st">"country"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## -- Imputation 1 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 2 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 3 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 4 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 5 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Amelia output with 5 imputed datasets.</span></span>
<span><span class="co">## Return code:  1 </span></span>
<span><span class="co">## Message:  Normal EM convergence. </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Chain Lengths:</span></span>
<span><span class="co">## --------------</span></span>
<span><span class="co">## Imputation 1:  18</span></span>
<span><span class="co">## Imputation 2:  13</span></span>
<span><span class="co">## Imputation 3:  14</span></span>
<span><span class="co">## Imputation 4:  17</span></span>
<span><span class="co">## Imputation 5:  15</span></span></code></pre>
<p>Note that Amelia will return with an error if your dataset contains a
factor or character variable that is not marked as a nominal or
identification variable. Thus, if we were to omit the factor
<code>country</code> from the <code>cs</code> or <code>idvars</code>
arguments, we would receive an error:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, idvars <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"year"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Amelia Error Code:  38 </span></span>
<span><span class="co">##  The following variable(s) are characters: </span></span>
<span><span class="co">##   country</span></span>
<span><span class="co">## You may have wanted to set this as a ID variable to remove it</span></span>
<span><span class="co">## from the imputation model or as an ordinal or nominal</span></span>
<span><span class="co">## variable to be imputed.  Please set it as either and</span></span>
<span><span class="co">## try again.</span></span></code></pre>
<p>In order to conserve memory, it is wise to remove unnecessary
variables from a data set before loading it into Amelia. The only
variables you should include in your data when running Amelia are
variables you will use in the analysis stage and those variables that
will help in the imputation model. While it may be tempting to simply
mark unneeded variables as IDs, it only serves to waste memory and slow
down the imputation procedure.</p>
</div>
<div class="section level2">
<h2 id="sec:tscs">Time Series, or Time Series Cross Sectional Data<a class="anchor" aria-label="anchor" href="#sec:tscs"></a>
</h2>
<p>Many variables that are recorded over time within a cross-sectional
unit are observed to vary smoothly over time. In such cases, knowing the
observed values of observations close in time to any missing value may
enormously aid the imputation of that value. However, the exact pattern
may vary over time within any cross-section. There may be periods of
growth, stability, or decline; in each of which the observed values
would be used in a different fashion to impute missing values. Also,
these patterns may vary enormously across different cross-sections, or
may exist in some and not others. Amelia can build a general model of
patterns within variables across time by creating a sequence of
polynomials of the time index. If, for example, tariffs vary smoothly
over time, then we make the modeling assumption that there exists some
polynomial that describes the economy in cross-sectional unit
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">tariff</mtext><mrow><mi>t</mi><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><mi>t</mi><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msup><mi>t</mi><mn>2</mn></msup><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msup><mi>t</mi><mn>3</mn></msup><mi>…</mi></mrow><annotation encoding="application/x-tex">
\textrm{tariff}_{ti} = \beta_0 + \beta_1 t + \beta_1 t^2 + \beta_1 t^3 \ldots
</annotation></semantics></math></p>
<p>And thus if we include enough higher order terms of time then the
pattern between observed values of the tariff rate can be estimated.
Amelia will create polynomials of time up to the user defined
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-th
order,
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k\leq3</annotation></semantics></math>).</p>
<p>We can implement this with the <code>ts</code> and
<code>polytime</code> arguments. If we thought that a second-order
polynomial would help predict we could run</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, polytime <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>With this input, Amelia will add covariates to the model that
correspond to time and its polynomials. These covariates will help
better predict the missing values.</p>
<p>If cross-sectional units are specified these polynomials can be
interacted with the cross-section unit to allow the patterns over time
to vary between cross-sectional units. Unless you strongly believe all
units have the same patterns over time in all variables (including the
same constant term), this is a reasonable setting. When
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is set to 0, this interaction simply results in a model of <em>fixed
effects</em> where every unit has a uniquely estimated constant term.
Amelia does not smooth the observed data, and only uses this functional
form, or one you choose, with all the other variables in the analysis
and the uncertainty of the prediction, to impute the missing values.</p>
<p>In order to impute with trends specific to each cross-sectional unit,
we can set <code>intercs</code> to <code>TRUE</code>:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out.time</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, polytime <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 intercs <span class="op">=</span> <span class="cn">TRUE</span>, p2s <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>Note that attempting to use <code>polytime</code> without the
<code>ts</code> argument, or <code>intercs</code> without the
<code>cs</code> argument will result in an error.</p>
<p>Using the <code><a href="../reference/tscsPlot.html">tscsPlot()</a></code> function (discussed below), we can
see that we have a much better prediction about the missing values when
incorporating time than when we omit it:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/tscsPlot.html">tscsPlot</a></span><span class="op">(</span><span class="va">a.out</span>, cs <span class="op">=</span> <span class="st">"Malaysia"</span>, main <span class="op">=</span> <span class="st">"Malaysia (no time settings)"</span>,</span>
<span>         var <span class="op">=</span> <span class="st">"tariff"</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">10</span>, <span class="fl">60</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="using-amelia_files/figure-html/tcomp1-1.png" width="480" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/tscsPlot.html">tscsPlot</a></span><span class="op">(</span><span class="va">a.out.time</span>, cs <span class="op">=</span> <span class="st">"Malaysia"</span>, main <span class="op">=</span> <span class="st">"Malaysia (with time settings)"</span>,</span>
<span>         var <span class="op">=</span> <span class="st">"tariff"</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">10</span>, <span class="fl">60</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="using-amelia_files/figure-html/tcomp1-2.png" width="480" style="display: block; margin: auto;"></p>
<div class="section level3">
<h3 id="sec:lags">Lags and leads<a class="anchor" aria-label="anchor" href="#sec:lags"></a>
</h3>
<p>An alternative way of handling time-series information is to include
lags and leads of certain variables into the imputation model.
<em>Lags</em> are variables that take the value of another variable in
the previous time period while <em>leads</em> take the value of another
variable in the next time period. Many analysis models use lagged
variables to deal with issues of endogeneity, thus using leads may seems
strange. It is important to remember, however, that imputation models
are predictive, not causal. Thus, since both past and future values of a
variable are likely correlated with the present value, both lags and
leads should improve the model.</p>
<p>If we wanted to include lags and leads of tariffs, for instance, we
would simply pass this to the <code>lags</code> and <code>leads</code>
arguments:</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, lags <span class="op">=</span> <span class="st">"tariff"</span>,</span>
<span>                 leads <span class="op">=</span> <span class="st">"tariff"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## -- Imputation 1 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 2 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</span></span>
<span><span class="co">##  21 22</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 3 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</span></span>
<span><span class="co">##  21 22</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 4 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 5 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</span></span>
<span><span class="co">##  21 22 23 24</span></span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="including-prior-information">Including Prior Information<a class="anchor" aria-label="anchor" href="#including-prior-information"></a>
</h2>
<p>Amelia has a number of methods of setting priors within the
imputation model. Two of these are commonly used and discussed below,
ridge priors and observational priors.</p>
<div class="section level3">
<h3 id="sec_prior">Ridge priors for high missingness, Small samples, or large
correlations<a class="anchor" aria-label="anchor" href="#sec_prior"></a>
</h3>
<p>When the data to be analyzed contain a high degree of missingness or
very strong correlations among the variables, or when the number of
observations is only slightly greater than the number of parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>+</mo><mn>3</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">p(p+3)/2</annotation></semantics></math>
(where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is the number of variables), results from your analysis model will be
more dependent on the choice of imputation model. This suggests more
testing in these cases of alternative specifications under Amelia. This
can happen when using the polynomials of time interacted with the cross
section are included in the imputation model. For example, in our data,
if we used a polynomial of degree 2 with unit-specific trends and there
are 9 countries, it would add
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>9</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>17</mn></mrow><annotation encoding="application/x-tex">3 \times 9 - 1= 17</annotation></semantics></math>
more variables to the imputation model (dropping one of the fixed
effects for identification). When these are added, the EM algorithm can
become unstable. You can detect this by inspecting the screen output
under <code>p2s = 2</code> or by observing that the number iterations
per imputation are very divergent.</p>
<p>In these circumstances, we recommend adding a ridge prior which will
help with numerical stability by shrinking the covariances among the
variables toward zero without changing the means or variances. This can
be done by including the <code>empri</code> argument. Including this
prior as a positive number is roughly equivalent to adding
<code>empri</code> artificial observations to the data set with the same
means and variances as the existing data but with zero covariances.
Thus, increasing the <code>empri</code> setting results in more
shrinkage of the covariances, thus putting more a priori structure on
the estimation problem: like many Bayesian methods, it reduces variance
in return for an increase in bias that one hopes does not overwhelm the
advantages in efficiency. In general, we suggest keeping the value on
this prior relatively small and increase it only when necessary. A
recommendation of 0.5 to 1 percent of the number of observations,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
is a reasonable starting value, and often useful in large datasets to
add some numerical stability. For example, in a dataset of two thousand
observations, this would translate to a prior value of 10 or 20
respectively. A prior of up to 5 percent is moderate in most
applications and 10 percent is reasonable upper bound.</p>
<p>For our data, it is easy to code up a 1 percent ridge prior:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out.time2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, polytime <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 intercs <span class="op">=</span> <span class="cn">TRUE</span>, p2s <span class="op">=</span> <span class="fl">0</span>, empri <span class="op">=</span> <span class="fl">.01</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">freetrade</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">a.out.time2</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Amelia output with 5 imputed datasets.</span></span>
<span><span class="co">## Return code:  1 </span></span>
<span><span class="co">## Message:  Normal EM convergence. </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Chain Lengths:</span></span>
<span><span class="co">## --------------</span></span>
<span><span class="co">## Imputation 1:  17</span></span>
<span><span class="co">## Imputation 2:  17</span></span>
<span><span class="co">## Imputation 3:  13</span></span>
<span><span class="co">## Imputation 4:  19</span></span>
<span><span class="co">## Imputation 5:  20</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="sec:obspri">Observation-level priors<a class="anchor" aria-label="anchor" href="#sec:obspri"></a>
</h3>
<p>Researchers often have additional prior information about missing
data values based on previous research, academic consensus, or personal
experience. Amelia can incorporate this information to produce vastly
improved imputations. The Amelia algorithm allows users to include
informative Bayesian priors about individual missing data cells instead
of the more general model parameters, many of which have little direct
meaning.</p>
<p>The incorporation of priors follows basic Bayesian analysis where the
imputation turns out to be a weighted average of the model-based
imputation and the prior mean, where the weights are functions of the
relative strength of the data and prior: when the model predicts very
well, the imputation will down-weight the prior, and vice versa <span class="citation">(<a href="#ref-HonKin10">Honaker and King
2010</a>)</span>.</p>
<p>The priors about individual observations should describe the
analyst’s belief about the distribution of the missing data cell. This
can either take the form of a mean and a standard deviation or a
confidence interval. For instance, we might know that 1986 tariff rates
in Thailand around 40%, but we have some uncertainty as to the exact
value. Our prior belief about the distribution of the missing data cell,
then, centers on 40 with a standard deviation that reflects the amount
of uncertainty we have about our prior belief.</p>
<p>To input priors you must build a priors matrix with either four or
five columns. Each row of the matrix represents a prior on either one
observation or one variable. In any row, the entry in the first column
is the row of the observation and the entry is the second column is the
column of the observation. In the four column priors matrix the third
and fourth columns are the mean and standard deviation of the prior
distribution of the missing value.</p>
<p>For instance, suppose that we had some expert prior information about
tariff rates in Thailand. We know from the data that Thailand is missing
tariff rates in many years,</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">freetrade</span><span class="op">[</span><span class="va">freetrade</span><span class="op">$</span><span class="va">country</span> <span class="op">==</span> <span class="st">"Thailand"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"year"</span>, <span class="st">"country"</span>, <span class="st">"tariff"</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##     year  country tariff</span></span>
<span><span class="co">## 153 1981 Thailand   32.3</span></span>
<span><span class="co">## 154 1982 Thailand     NA</span></span>
<span><span class="co">## 155 1983 Thailand     NA</span></span>
<span><span class="co">## 156 1984 Thailand     NA</span></span>
<span><span class="co">## 157 1985 Thailand   41.2</span></span>
<span><span class="co">## 158 1986 Thailand     NA</span></span>
<span><span class="co">## 159 1987 Thailand     NA</span></span>
<span><span class="co">## 160 1988 Thailand     NA</span></span>
<span><span class="co">## 161 1989 Thailand   40.8</span></span>
<span><span class="co">## 162 1990 Thailand   39.8</span></span>
<span><span class="co">## 163 1991 Thailand   37.8</span></span>
<span><span class="co">## 164 1992 Thailand     NA</span></span>
<span><span class="co">## 165 1993 Thailand   45.6</span></span>
<span><span class="co">## 166 1994 Thailand   23.3</span></span>
<span><span class="co">## 167 1995 Thailand   23.1</span></span>
<span><span class="co">## 168 1996 Thailand     NA</span></span>
<span><span class="co">## 169 1997 Thailand     NA</span></span>
<span><span class="co">## 170 1998 Thailand   20.1</span></span>
<span><span class="co">## 171 1999 Thailand   17.1</span></span></code></pre>
<p>Suppose that we had expert information that tariff rates were roughly
40% in Thailand between 1986 and 1988 with about a 6% margin of error.
This corresponds to a standard deviation of about 3. In order to include
this information, we must form the priors matrix:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">158</span>, <span class="fl">159</span>, <span class="fl">160</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">3</span><span class="op">)</span>,</span>
<span>  nrow <span class="op">=</span> <span class="fl">3</span>, ncol <span class="op">=</span> <span class="fl">4</span></span>
<span><span class="op">)</span></span>
<span><span class="va">pr</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3] [,4]</span></span>
<span><span class="co">## [1,]  158    3   40    3</span></span>
<span><span class="co">## [2,]  159    3   40    3</span></span>
<span><span class="co">## [3,]  160    3   40    3</span></span></code></pre>
<p>The first column of this matrix corresponds to the row numbers of
Thailand in these three years, the second column refers to the column
number of <code>tariff</code> in the data and the last two columns refer
to the actual prior. Once we have this matrix, we can pass it to
<code><a href="../reference/amelia.html">amelia()</a></code>,</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out.pr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, priors <span class="op">=</span> <span class="va">pr</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## -- Imputation 1 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 2 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 3 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 4 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 5 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14</span></span></code></pre>
<p>In the five column matrix, the last three columns describe a
confidence range of the data. The columns are a lower bound, an upper
bound, and a confidence level between 0 and 1, exclusive. Whichever
format you choose, it must be consistent across the entire matrix. We
could get roughly the same prior as above by utilizing this method. Our
margin of error implies that we would want imputations between 34 and
46, so our matrix would be</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pr.2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">158</span>, <span class="fl">159</span>, <span class="fl">160</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">34</span>, <span class="fl">34</span>, <span class="fl">34</span>, <span class="fl">46</span>, <span class="fl">46</span>, <span class="fl">46</span>, <span class="fl">0.95</span>, <span class="fl">0.95</span>, <span class="fl">0.95</span><span class="op">)</span>,</span>
<span>  nrow <span class="op">=</span> <span class="fl">3</span>, ncol <span class="op">=</span> <span class="fl">5</span></span>
<span><span class="op">)</span></span>
<span><span class="va">pr.2</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3] [,4] [,5]</span></span>
<span><span class="co">## [1,]  158    3   34   46 0.95</span></span>
<span><span class="co">## [2,]  159    3   34   46 0.95</span></span>
<span><span class="co">## [3,]  160    3   34   46 0.95</span></span></code></pre>
<p>These priors indicate that we are 95% confident that these missing
values are in the range 34 to 46.</p>
<p>If a prior has the value 0 in the first column, this prior will be
applied to all missing values in this variable, except for explicitly
set priors. Thus, we could set a prior for the entire
<code>tariff</code> variable of 20, but still keep the above specific
priors with the following code:</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pr.3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">158</span>, <span class="fl">159</span>, <span class="fl">160</span>, <span class="fl">0</span>, <span class="fl">3</span>, <span class="fl">3</span> , <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">40</span>, <span class="fl">20</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">5</span><span class="op">)</span>,</span>
<span>  nrow <span class="op">=</span> <span class="fl">4</span>, ncol <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="va">pr.3</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3] [,4]</span></span>
<span><span class="co">## [1,]  158    3   40    3</span></span>
<span><span class="co">## [2,]  159    3   40    3</span></span>
<span><span class="co">## [3,]  160    3   40    3</span></span>
<span><span class="co">## [4,]    0    3   20    5</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="logical-bounds">Logical bounds<a class="anchor" aria-label="anchor" href="#logical-bounds"></a>
</h3>
<p>In some cases, variables in the social sciences have known logical
bounds. Proportions must be between 0 and 1 and duration data must be
greater than 0, for instance. Many of these logical bounds can be
handled by using the correct transformation for that type of variable
(see @ref(sec:trans) for more details on the transformations handled by
Amelia). In the occasional case that imputations must satisfy certain
logical bounds not handled by these transformations, Amelia can take
draws from a truncated normal distribution in order to achieve
imputations that satisfy the bounds. Note, however, that this procedure
imposes extremely strong restrictions on the imputations and can lead to
lower variances than the imputation model implies. The mean value across
all the imputed values of a missing cell is the best guess from the
imputation model of that missing value. The variance of the distribution
across imputed datasets correctly reflects the uncertainty in that
imputation. It is often the mean imputed value that should conform to
the any known bounds, even if individual imputations are drawn beyond
those bounds. The mean imputed value can be checked with the diagnostics
presented in the next section. In general, building a more predictive
imputation model will lead to better imputations than imposing
bounds.</p>
<p>Amelia implements these bounds by rejection sampling. When drawing
the imputations from their posterior, we repeatedly resample until we
have a draw that satisfies all of the logical constraints. You can set
an upper limit on the number of times to resample with the
<code>max.resample</code> arguments. Thus, if after
<code>max.resample</code> draws, the imputations are still outside the
bounds, Amelia will set the imputation at the edge of the bounds. Thus,
if the bounds were 0 and 100 and all of the draws were negative, Amelia
would simply impute 0.</p>
<p>As an extreme example, suppose that we know, for certain that tariff
rates had to fall between 30 and 40. This, obviously, is not true, but
we can generate imputations from this model. In order to specify these
bounds, we need to generate a matrix of bounds to pass to the
<code>bounds</code> argument. This matrix will have 3 columns: the first
is the column for the bounded variable, the second is the lower bound
and the third is the upper bound. Thus, to implement our bound on tariff
rates (the 3rd column of the dataset), we would create the matrix,</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bds</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">30</span>, <span class="fl">40</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">1</span>, ncol <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">bds</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]    3   30   40</span></span></code></pre>
<p>which we can pass to the <code>bounds</code> argument to
<code><a href="../reference/amelia.html">amelia()</a></code>:</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out.bds</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/amelia.html">amelia</a></span><span class="op">(</span><span class="va">freetrade</span>, ts <span class="op">=</span> <span class="st">"year"</span>, cs <span class="op">=</span> <span class="st">"country"</span>, bounds <span class="op">=</span> <span class="va">bds</span>,</span>
<span>                    max.resample <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## -- Imputation 1 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 2 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 3 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 4 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10 11 12 13</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## -- Imputation 5 --</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   1  2  3  4  5  6  7  8  9 10</span></span></code></pre>
<p>The difference in results between the bounded and unbounded model are
not obvious from the output, but inspection of the imputed tariff rates
for Malaysia shows that there has been a drastic restriction of the
imputations to the desired range:</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/tscsPlot.html">tscsPlot</a></span><span class="op">(</span><span class="va">a.out</span>, cs <span class="op">=</span> <span class="st">"Malaysia"</span>, main <span class="op">=</span> <span class="st">"No logical bounds"</span>, var <span class="op">=</span> <span class="st">"tariff"</span>,</span>
<span>         ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">10</span>, <span class="fl">60</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="using-amelia_files/figure-html/bounds_plot-1.png" width="480" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/tscsPlot.html">tscsPlot</a></span><span class="op">(</span><span class="va">a.out.bds</span>, cs <span class="op">=</span> <span class="st">"Malaysia"</span>, main <span class="op">=</span> <span class="st">"Bounded between 30 and 40"</span>,</span>
<span>         var <span class="op">=</span> <span class="st">"tariff"</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">10</span>, <span class="fl">60</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="using-amelia_files/figure-html/bounds_plot-2.png" width="480" style="display: block; margin: auto;"></p>
<p>Again, analysts should be extremely cautious when using these bounds
as they can seriously affect the inferences from the imputation model,
as shown in this example. Even when logical bounds exist, we recommend
simply imputing variables normally, as the violation of the logical
bounds represents part of the true uncertainty of imputation.</p>
</div>
</div>
<div class="section level2">
<h2 id="sec_postimptrans">Post-imputations Transformations<a class="anchor" aria-label="anchor" href="#sec_postimptrans"></a>
</h2>
<p>In many cases, it is useful to create transformations of the imputed
variables for use in further analysis. For instance, one may want to
create an interaction between two variables or perform a
log-transformation on the imputed data. To do this, Amelia includes a
<code><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform()</a></code> function for <code><a href="../reference/amelia.html">amelia()</a></code> output that
adds or overwrites variables in each of the imputed datasets. For
instance, if we wanted to create a log-transformation of the
<code>gdp.pc</code> variable, we could use the following command:</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">a.out</span>, lgdp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">gdp.pc</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">a.out</span><span class="op">$</span><span class="va">imputations</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"country"</span>, <span class="st">"year"</span>,<span class="st">"gdp.pc"</span>, <span class="st">"lgdp"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##    country year gdp.pc  lgdp</span></span>
<span><span class="co">## 1 SriLanka 1981  461.0 6.133</span></span>
<span><span class="co">## 2 SriLanka 1982  473.8 6.161</span></span>
<span><span class="co">## 3 SriLanka 1983  489.2 6.193</span></span>
<span><span class="co">## 4 SriLanka 1984  508.2 6.231</span></span>
<span><span class="co">## 5 SriLanka 1985  525.6 6.264</span></span>
<span><span class="co">## 6 SriLanka 1986  538.9 6.290</span></span></code></pre>
<p>To create an interaction between two variables, we could simply
use:</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">a.out</span>, pol_gdp <span class="op">=</span> <span class="va">polity</span> <span class="op">*</span> <span class="va">gdp.pc</span><span class="op">)</span></span></code></pre></div>
<p>Each transformation is recorded and the <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>
command prints out each transformation that has been performed:</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">a.out</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Amelia output with 5 imputed datasets.</span></span>
<span><span class="co">## Return code:  1 </span></span>
<span><span class="co">## Message:  Normal EM convergence. </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Chain Lengths:</span></span>
<span><span class="co">## --------------</span></span>
<span><span class="co">## Imputation 1:  14</span></span>
<span><span class="co">## Imputation 2:  14</span></span>
<span><span class="co">## Imputation 3:  16</span></span>
<span><span class="co">## Imputation 4:  15</span></span>
<span><span class="co">## Imputation 5:  18</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rows after Listwise Deletion:  96 </span></span>
<span><span class="co">## Rows after Imputation:  171 </span></span>
<span><span class="co">## Patterns of missingness in the data:  8 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fraction Missing for original variables: </span></span>
<span><span class="co">## -----------------------------------------</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##          Fraction Missing</span></span>
<span><span class="co">## year              0.00000</span></span>
<span><span class="co">## country           0.00000</span></span>
<span><span class="co">## tariff            0.33918</span></span>
<span><span class="co">## polity            0.01170</span></span>
<span><span class="co">## pop               0.00000</span></span>
<span><span class="co">## gdp.pc            0.00000</span></span>
<span><span class="co">## intresmi          0.07602</span></span>
<span><span class="co">## signed            0.01754</span></span>
<span><span class="co">## fiveop            0.10526</span></span>
<span><span class="co">## usheg             0.00000</span></span>
<span><span class="co">## lgdp              0.00000</span></span>
<span><span class="co">## pol_gdp           0.01170</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Post-imputation transformed variables: </span></span>
<span><span class="co">## -----------------------------------------</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##           Transformations</span></span>
<span><span class="co">## lgdp =        log(gdp.pc)</span></span>
<span><span class="co">## pol_gdp = polity * gdp.pc</span></span></code></pre>
<p>Note the updated output is almost exactly the same as the fresh
<code><a href="../reference/amelia.html">amelia()</a></code> output. You can pass the transformed output back
to <code><a href="../reference/amelia.html">amelia()</a></code> and it will add imputations and update these
imputations with the transformations you have performed.</p>
</div>
<div class="section level2">
<h2 id="sec_analysis">Analysis Models<a class="anchor" aria-label="anchor" href="#sec_analysis"></a>
</h2>
<p>Imputation is most often a data processing step as opposed to a final
model in of itself. To this end, it is easy to pass output from
<code><a href="../reference/amelia.html">amelia()</a></code> to other functions. The easiest and most
integrated way to run an analysis model is to use the
<code><a href="https://rdrr.io/r/base/with.html" class="external-link">with()</a></code> and <code><a href="../reference/mi.combine.html">mi.combine()</a></code> functions. For
example, in <span class="citation">Milner and Kubota (<a href="#ref-MilKub05">2005</a>)</span>, the dependent variable was tariff
rates. We can replicate table 5.1 from their analysis with the original
data simply by running</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">orig.model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">tariff</span> <span class="op">~</span> <span class="va">polity</span> <span class="op">+</span> <span class="va">pop</span> <span class="op">+</span> <span class="va">gdp.pc</span> <span class="op">+</span> <span class="va">year</span> <span class="op">+</span> <span class="va">country</span>, data <span class="op">=</span> <span class="va">freetrade</span><span class="op">)</span></span>
<span><span class="va">orig.model</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## lm(formula = tariff ~ polity + pop + gdp.pc + year + country, </span></span>
<span><span class="co">##     data = freetrade)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Coefficients:</span></span>
<span><span class="co">##        (Intercept)              polity                 pop              gdp.pc  </span></span>
<span><span class="co">##           1.97e+03           -1.37e-01           -2.02e-07            6.10e-04  </span></span>
<span><span class="co">##               year    countryIndonesia        countryKorea     countryMalaysia  </span></span>
<span><span class="co">##          -8.71e-01           -1.82e+02           -2.20e+02           -2.25e+02  </span></span>
<span><span class="co">##       countryNepal     countryPakistan  countryPhilippines     countrySriLanka  </span></span>
<span><span class="co">##          -2.16e+02           -1.55e+02           -2.04e+02           -2.09e+02  </span></span>
<span><span class="co">##    countryThailand  </span></span>
<span><span class="co">##          -1.96e+02</span></span></code></pre>
<p>Running the same model with imputed data is almost identical. We can
run the <code>lm</code> within each imputed data set by using the
<code><a href="https://rdrr.io/r/base/with.html" class="external-link">with()</a></code> function:</p>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">imp.models</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html" class="external-link">with</a></span><span class="op">(</span></span>
<span>  <span class="va">a.out</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">tariff</span> <span class="op">~</span> <span class="va">polity</span> <span class="op">+</span> <span class="va">pop</span> <span class="op">+</span> <span class="va">gdp.pc</span> <span class="op">+</span> <span class="va">year</span> <span class="op">+</span> <span class="va">country</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">imp.models</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## lm(formula = tariff ~ polity + pop + gdp.pc + year + country)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Coefficients:</span></span>
<span><span class="co">##        (Intercept)              polity                 pop              gdp.pc  </span></span>
<span><span class="co">##           2.44e+03            3.54e-01           -7.78e-08           -2.41e-04  </span></span>
<span><span class="co">##               year    countryIndonesia        countryKorea     countryMalaysia  </span></span>
<span><span class="co">##          -1.17e+00           -7.97e+01           -9.96e+01           -1.00e+02  </span></span>
<span><span class="co">##       countryNepal     countryPakistan  countryPhilippines     countrySriLanka  </span></span>
<span><span class="co">##          -9.41e+01           -5.53e+01           -9.26e+01           -9.38e+01  </span></span>
<span><span class="co">##    countryThailand  </span></span>
<span><span class="co">##          -8.69e+01  </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## lm(formula = tariff ~ polity + pop + gdp.pc + year + country)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Coefficients:</span></span>
<span><span class="co">##        (Intercept)              polity                 pop              gdp.pc  </span></span>
<span><span class="co">##           2.43e+03           -1.66e-02           -1.40e-07            1.23e-03  </span></span>
<span><span class="co">##               year    countryIndonesia        countryKorea     countryMalaysia  </span></span>
<span><span class="co">##          -1.13e+00           -1.28e+02           -1.72e+02           -1.67e+02  </span></span>
<span><span class="co">##       countryNepal     countryPakistan  countryPhilippines     countrySriLanka  </span></span>
<span><span class="co">##          -1.54e+02           -1.08e+02           -1.51e+02           -1.55e+02  </span></span>
<span><span class="co">##    countryThailand  </span></span>
<span><span class="co">##          -1.49e+02</span></span></code></pre>
<p>The result here is simply a list of output of <code><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm()</a></code>
applied to each imputed data set. We can combine the imputed estimates
using the rules described in <span class="citation">King et al. (<a href="#ref-KinHonJos01">2001</a>)</span> and <span class="citation">Schafer (<a href="#ref-Schafer97">1997</a>)</span> with
the <code><a href="../reference/mi.combine.html">mi.combine()</a></code> function:</p>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mi.combine.html">mi.combine</a></span><span class="op">(</span><span class="va">imp.models</span>, conf.int <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">out</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 13 × 10</span></span></span>
<span><span class="co">##    term      estimate std.error statistic p.value    df     r miss.info conf.low</span></span>
<span><span class="co">##    <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>        <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>   <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 1</span> (Interce…  2.72<span style="color: #949494;">e</span>+3   6.33<span style="color: #949494;">e</span>+2     4.31  2.21<span style="color: #949494;">e</span><span style="color: #BB0000;">-4</span> 25.2  0.662     0.441  4.03<span style="color: #949494;">e</span>+3</span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 2</span> polity     1.61<span style="color: #949494;">e</span><span style="color: #BB0000;">-1</span>   3.29<span style="color: #949494;">e</span><span style="color: #BB0000;">-1</span>     0.488 6.29<span style="color: #949494;">e</span><span style="color: #BB0000;">-1</span> 36.9  0.491     0.363  8.28<span style="color: #949494;">e</span><span style="color: #BB0000;">-1</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 3</span> pop       -<span style="color: #BB0000;">9.80</span><span style="color: #949494;">e</span><span style="color: #BB0000;">-8</span>   5.30<span style="color: #949494;">e</span><span style="color: #BB0000;">-8</span>    -<span style="color: #BB0000;">1.85</span>  1.91<span style="color: #949494;">e</span>+0 12.0  1.37      0.634  1.74<span style="color: #949494;">e</span><span style="color: #BB0000;">-8</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 4</span> gdp.pc     2.20<span style="color: #949494;">e</span><span style="color: #BB0000;">-4</span>   1.35<span style="color: #949494;">e</span><span style="color: #BB0000;">-3</span>     0.163 8.71<span style="color: #949494;">e</span><span style="color: #BB0000;">-1</span> 35.8  0.502     0.368  2.96<span style="color: #949494;">e</span><span style="color: #BB0000;">-3</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 5</span> year      -<span style="color: #BB0000;">1.30</span><span style="color: #949494;">e</span>+0   3.33<span style="color: #949494;">e</span><span style="color: #BB0000;">-1</span>    -<span style="color: #BB0000;">3.89</span>  2.00<span style="color: #949494;">e</span>+0 23.3  0.708     0.459 -<span style="color: #BB0000;">6.09</span><span style="color: #949494;">e</span><span style="color: #BB0000;">-1</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 6</span> countryI… -<span style="color: #BB0000;">9.72</span><span style="color: #949494;">e</span>+1   3.97<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">2.45</span>  1.97<span style="color: #949494;">e</span>+0 10.1  1.70      0.686 -<span style="color: #BB0000;">8.75</span><span style="color: #949494;">e</span>+0</span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 7</span> countryK… -<span style="color: #BB0000;">1.25</span><span style="color: #949494;">e</span>+2   4.82<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">2.59</span>  1.97<span style="color: #949494;">e</span>+0  8.93 2.02      0.725 -<span style="color: #BB0000;">1.54</span><span style="color: #949494;">e</span>+1</span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 8</span> countryM… -<span style="color: #BB0000;">1.25</span><span style="color: #949494;">e</span>+2   4.73<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">2.64</span>  1.97<span style="color: #949494;">e</span>+0  9.85 1.76      0.694 -<span style="color: #BB0000;">1.92</span><span style="color: #949494;">e</span>+1</span></span>
<span><span class="co">## <span style="color: #BCBCBC;"> 9</span> countryN… -<span style="color: #BB0000;">1.17</span><span style="color: #949494;">e</span>+2   4.67<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">2.50</span>  1.97<span style="color: #949494;">e</span>+0 10.8  1.56      0.666 -<span style="color: #BB0000;">1.36</span><span style="color: #949494;">e</span>+1</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">10</span> countryP… -<span style="color: #BB0000;">7.34</span><span style="color: #949494;">e</span>+1   4.27<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">1.72</span>  1.88<span style="color: #949494;">e</span>+0 10.1  1.69      0.685  2.15<span style="color: #949494;">e</span>+1</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">11</span> countryP… -<span style="color: #BB0000;">1.13</span><span style="color: #949494;">e</span>+2   4.52<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">2.51</span>  1.97<span style="color: #949494;">e</span>+0 10.0  1.72      0.689 -<span style="color: #BB0000;">1.27</span><span style="color: #949494;">e</span>+1</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">12</span> countryS… -<span style="color: #BB0000;">1.15</span><span style="color: #949494;">e</span>+2   4.75<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">2.41</span>  1.96<span style="color: #949494;">e</span>+0 10.1  1.69      0.685 -<span style="color: #BB0000;">8.80</span><span style="color: #949494;">e</span>+0</span></span>
<span><span class="co">## <span style="color: #BCBCBC;">13</span> countryT… -<span style="color: #BB0000;">1.08</span><span style="color: #949494;">e</span>+2   4.57<span style="color: #949494;">e</span>+1    -<span style="color: #BB0000;">2.36</span>  1.96<span style="color: #949494;">e</span>+0  9.74 1.79      0.697 -<span style="color: #BB0000;">5.66</span><span style="color: #949494;">e</span>+0</span></span>
<span><span class="co">## <span style="color: #949494;"># ℹ 1 more variable: conf.high &lt;dbl&gt;</span></span></span></code></pre>
<p>The combination of the results depends on the <a href="https://broom.tidymodels.org" class="external-link">broom</a> package and results can be
combined if a <code>tidy()</code> method exists for the estimation
function passed to <code><a href="https://rdrr.io/r/base/with.html" class="external-link">with()</a></code>. Other packages such as <a href="https://docs.zeligproject.org/index.html" class="external-link">Zelig</a> can also
combine imputed data sets across a number of statistical models.
Furthermore, users can easily export their imputations using the
<code><a href="../reference/write.amelia.html">write.amelia()</a></code> function as described in @ref(sec_saving)
and use statistical packages other than R for the analysis model.</p>
<p>In addition to the resources available in R, users can draw on Stata
to implement their analysis models. As of version 11, Stata has built-in
handling of multiply imputed datasets. In order to utilize this
functionality, simply export the “stacked” imputations using the
<code><a href="../reference/write.amelia.html">write.amelia()</a></code> function:</p>
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/write.amelia.html">write.amelia</a></span><span class="op">(</span><span class="va">a.out</span>, separate <span class="op">=</span> <span class="cn">FALSE</span>, file.stem <span class="op">=</span> <span class="st">"outdata"</span>, format <span class="op">=</span> <span class="st">"dta"</span><span class="op">)</span></span></code></pre></div>
<p>Once this stacked dataset is open in Stata, you must tell Stata that
it is an imputed dataset using the command:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode stata"><code class="sourceCode stata"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a><span class="fu">mi</span> import flong, <span class="fu">m</span>(imp) id(<span class="fu">year</span> country) imp(tariff-usheg)</span></code></pre></div>
<p>The command takes a few options: <code>m</code> designates the
imputation variable (set with <code>impvar</code> in
<code><a href="../reference/write.amelia.html">write.amelia()</a></code>), <code>id</code> sets the identifying
varibles, and <code>imp</code> sets the variables that were imputed (or
included in the imputation). The <code>tariff-usheg</code> indicates
that Stata should treat the range of variables between
<code>tariff</code> and <code>usheg</code> as imputed. Once we have set
the dataset as imputed, we can use the built-in <code>mi</code> commands
to analyze the data:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode stata"><code class="sourceCode stata"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="fu">mi</span> estimate: <span class="kw">reg</span> tariff polity pop gdp_pc</span></code></pre></div>
<pre><code>Multiple-imputation estimates                     Imputations     =          5
Linear regression                                 Number of obs   =        171
                                                  Average RVI     =     1.4114
                                                  Complete DF     =        167
DF adjustment:   Small sample                     DF:     min     =      10.36
                                                          avg     =      18.81
                                                          max     =      37.62
Model F test:       Equal FMI                     F(   2,   10.4) =      15.50
Within VCE type:          OLS                     Prob &gt; F        =     0.0008

------------------------------------------------------------------------------
      tariff |      Coef.   Std. Err.      t    P&gt;|t|     [95% Conf. Interval]
-------------+----------------------------------------------------------------
      polity |  -.2058115   .3911049    -0.53   0.610    -1.072968    .6613452
         pop |   3.21e-08   8.72e-09     3.68   0.004     1.27e-08    5.14e-08
      gdp_pc |  -.0027561    .000644    -4.28   0.000    -.0040602   -.0014519
       _cons |   32.70461   2.660091    12.29   0.000     27.08917    38.32005
------------------------------------------------------------------------------</code></pre>
</div>
<div class="section level2">
<h2 id="sec_out">The <code>amelia</code> class<a class="anchor" aria-label="anchor" href="#sec_out"></a>
</h2>
<p>The output from the <code><a href="../reference/amelia.html">amelia()</a></code> function is an instance of
the S3 class <code>amelia</code>. Instances of the <code>amelia</code>
class contain much more than simply the imputed datasets. The
<code>mu</code> object of the class contains the posterior draws of the
means of the complete data. The <code>covMatrices</code> contains the
posterior draws of the covariance matrices of the complete data. Note
that these correspond to the variables as they are sent to the EM
algorithm. Namely, they refer to the variables after being transformed,
centered and scaled.</p>
<p>The <code>iterHist</code> object is a list of <code>m</code> 3-column
matrices. Each row of the matrices corresponds to an iteration of the EM
algorithm. The first column indicates how many parameters had yet to
converge at that iteration. The second column indicates if the EM
algorithm made a step that decreased the number of converged parameters.
The third column indicates whether the covariance matrix at this
iteration was singular. Clearly, the last two columns are meant to
indicate when the EM algorithm enters a problematic part of the
parameter space.</p>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-HonKin10" class="csl-entry">
Honaker, James, and Gary King. 2010. <span>“What to Do about Missing
Values in Time Series Cross-Section Data.”</span> <em>American Journal
of Political Science</em> 54 (2): 561–81.
</div>
<div id="ref-KinHonJos01" class="csl-entry">
King, Gary, James Honaker, Anne Joseph, and Kenneth Scheve. 2001.
<span>“Analyzing Incomplete Political Science Data: An Alternative
Algorithm for Multiple Imputation.”</span> <em>American Political
Science Review</em> 95 (1): 49–69.
</div>
<div id="ref-MilKub05" class="csl-entry">
Milner, Helen, and Keiko Kubota. 2005. <span>“<span class="nocase">Why
the move to free trade? Democracy and trade policy in the developing
countries</span>.”</span> <em>International Organization</em> 59 (1):
107–43.
</div>
<div id="ref-Schafer97" class="csl-entry">
Schafer, Joseph L. 1997. <em>Analysis of Incomplete Multivariate
Data</em>. London: Chapman &amp; Hall.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>We have artificially addedsome missingness to these data
for presentational purposes. You can access the original data at <a href="https://hvmilner.scholar.princeton.edu/data" class="external-link">https://hvmilner.scholar.princeton.edu/data</a>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>The Polity score is a number between -10 and 10
indicating how democratic a country is. A fully autocratic country would
be a -10 while a fully democratic country would be 1 10.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>This measure of US hegemony is the US imports and
exports as a percent of the world total imports and exports.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>Dichotomous (two category) variables are a special case
of nominal variables. For these variables, the nominal and ordinal
methods of transformation in Amelia agree.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by <a href="https://hona.kr" class="external-link">James Honaker</a>, <a href="https://gking.harvard.edu" class="external-link">Gary King</a>, <a href="https://www.mattblackwell.org" class="external-link">Matthew Blackwell</a>.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

      </footer>
</div>






  </body>
</html>
