\documentclass[12pt,letterpaper]{article}
%\usepackage{/usr/lib64/R/share/texmf/Rd}
%\usepackage{/usr/lib64/R/share/texmf/Sweave}
%\usepackage{/usr/lib64/R/share/texmf/upquote}


% === for bad lm output === 
% this wasn't working with rbuild 
%% so i took out the signficance stars
%\usepackage[utf8]{inputenc}

\usepackage{Rd/Rd}
\usepackage{Rd/Sweave}
\usepackage{Rd/upquote}

\SweaveOpts{width=70}

% === graphic packages ===
\usepackage{graphicx}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

% === bibliography package ===
\usepackage{natbib}
% === margin and formatting ===
\usepackage{setspace}
\usepackage{fullpage}
\usepackage{caption}
% === math packages ===
\usepackage[reqno]{amsmath}
\usepackage{amsthm}
\usepackage{amssymb,enumerate}
\newtheorem{Com} {Comment}
\newtheorem{prop}{Proposition}
\newtheorem{thm}{Theorem}
% === dcolumn package ===
\usepackage{dcolumn}
\newcolumntype{.}{D{.}{.}{-1}}
\newcolumntype{d}[1]{D{.}{.}{#1}}
% === additional packages ===
\usepackage{url}
\setcounter{tocdepth}{4}

%% \VingetteIndexEntry{A Guide to Amelia}
\usepackage{color}
\usepackage[pdftex, bookmarksopen=true, bookmarksnumbered=true,
pdfstartview=FitH, breaklinks=true, urlbordercolor={0 1 0},
citebordercolor={0 0 1}]{hyperref}

\newcommand{\obs}{{\text{obs}}}
\newcommand{\mis}{{\text{mis}}}
%\newcommand{\Amelia}{\texttt{Amelia}}
\renewcommand{\R}{\textsf{R}}
\newcommand{\Amelia}{\ensuremath{\mathbb A}melia}
\newcommand{\AmeliaII}{\ensuremath{\mathbb A}melia~\ensuremath{\mathbb{II}}}
\newcommand{\AmeliaView}{\ensuremath{\mathbb A}melia\ensuremath{\mathbb{V}}iew}
\newcommand{\adjparbox}[2]{\parbox{#1}{\vspace{.35em}#2\vspace{.35em}}}
\usepackage{vmargin}
\topmargin=0in

\title{${\mathbb{AMELIA~II}}$: A Program for Missing Data}

% rbuild: replace 'Version ' '\\' Version
\date{Version \\ \today}

\author{James Honaker, Gary King, and Matthew Blackwell}

\begin{document}
\maketitle

\tableofcontents
\newpage



\section{Introduction}
\label{sec:intro}
Missing data is a perennial problem in social science data.
Respondents do not answer every question, countries do not collect
statistics in every year and, most unfortunately, researchers do not
always have the resources to collect every piece of available data.
Most statistical analysis methods, however, assume the absence of
missing data. \AmeliaII\ allows users to impute (``fill in'' or
rectangularize) incomplete data sets so that analyses which require
complete observations can appropriately use all the information
present in a dataset with missingness, and avoid the biases,
inefficiencies, and incorrect uncertainty estimates that can result
from dropping all partially observed observations from the analysis.

\AmeliaII\ performs \emph{multiple imputation}, a general-purpose
approach to data with missing values. Multiple imputation has been
shown to reduce bias and increase efficiency compared to listwise
deletion. Furthermore, ad-hoc methods of imputation, such as mean
imputation, can lead to serious biases in variances and covariances.
Unfortunately, creating multiple imputations can be a burdensome
process due to technical nature of algorithms involved. \Amelia
provides users with a simple way to create an imputation model,
implement it, and check its fit using diagnostics.

The \AmeliaII\ program goes several significant steps beyond the
capabilities of the first version of \Amelia\ \citep*{HonJosKin98}.
For one, the bootstrap-based EMB algorithm included in \AmeliaII\ can
impute many more variables, with many more observations, in much less
time.  The great simplicity and power of the EMB algorithm made it
possible to write \AmeliaII\ so that it virtually never crashes ---
which to our knowledge makes it unique among all existing multiple
imputation software --- and is much faster than the alternatives too.
\AmeliaII\ also has features to make valid and much more accurate
imputations for cross-sectional, time-series, and
time-series-cross-section data, and allows the incorporation of
observation and data-matrix-cell level prior information. In addition
to all of this, \AmeliaII\ provides many diagnostic functions that
help users check the validity of their imputation model.  This
software implements the ideas developed in \citet*{HonKin09}.

\section{What \Amelia\ Does}
\label{sec:what}

Multiple imputation involves imputing $m$ values for each missing cell
in your data matrix and creating $m$ ``completed'' data sets.  (Across
these completed data sets, the observed values are the same, but the
missing values are filled in with different imputations that reflect
the uncertainty about the missing data.)  After imputation with
\AmeliaII's EMB algorithm, you can apply whatever statistical method
you would have used if there had been no missing values in each of the
$m$ data sets, and use a simple procedure, described below, to combine
the results\footnote{(You can combine the results automatically by
  doing your data analyses within Zelig for R, or within Clarify for
  Stata; see \url{http://gking.harvard.edu/stats.shtml}.}.  Under
normal circumstances, you only need to impute once and can then
analyze the $m$ imputed data sets as many times and for as many
purposes as you wish.  The advantage of \AmeliaII\ is that it combines
the comparative speed and ease-of-use of our algorithm with the power
of multiple imputation, to let you focus on your substantive research
questions rather than spending time developing complex
application-specific models for nonresponse in each new data set.
Unless the rate of missingness is very high, $m = 5$ (the program
default) is probably adequate.

\subsection{Assumptions}

The imputation model in \AmeliaII\ assumes that the complete data (that
is, both observed and unobserved) are multivariate normal. If we denote
the $(n \times k)$ dataset as $D$ (with observed part $D^{\obs}$ and
unobserved part $D^{\mis}$), then this assumption is
\begin{equation}
  \label{eq:norm}
  D \sim \mathcal{N}_k(\mu, \Sigma),
\end{equation}
which states that $D$ has a multivariate normal distribution with mean
vector $\mu$ and covariance matrix $\Sigma$. The multivariate normal
distribution is often a crude approximation to the true distribution of
the data, yet there is evidence that this model works as well as other,
more complicated models even in the face of categorical or mixed data
\citep[see][]{Schafer97, SchOls98}. Furthermore, transformations of the data
can often make this normality assumption more plausible (see
\ref{sec:trans} for more information on how to implement this in \Amelia).

The essential problem of imputation is that we only observe
$D^{\obs}$, not all of $D$. In order to gain traction, we need to make
the usual assumption in multiple imputation that the data are
\emph{missing at random} (MAR). This assumption means that the pattern
of missingness only depends on the observed data $D^{\obs}$, not the
unobserved data $D^{\mis}$. Let $M$ to be the missingness matrix, with
cells $m_{ij} = 1$ if $d_{ij} \in D^{\mis}$ and $m_{ij} = 0$
otherwise.  Put simply, $M$ is a matrix that indicates whether or not
a cell is missing in the data. With this, we can define the MAR
assumption as
\begin{equation}
  \label{eq:mar}
  p(M|D) = p(M|D^{\obs}).
\end{equation}
Note that MAR includes the case when missing values are created
randomly by, say, coin flips, but it also includes many more
sophisticated missingness models.  When missingness is not dependent
on the data at all, we say that the data are \emph{missing completely
  at random} (MCAR).  \Amelia\ requires both the multivariate
normality and the MAR assumption (or the simpler special case of
MCAR).  Note that the MAR assumption can be made more plausible by
including more information into the imputation model.


\subsection{Algorithm}

In multiple imputation, we are concerned with the complete-data
parameters, $\theta = (\mu, \Sigma)$. When writing down a model of the
data, it is clear that our observed data is actually $D^{\obs}$ and $M$,
the missingness matrix. Thus, the likelihood of our observed data is
$p(D^{\obs}, M|\theta)$. Using the MAR assumption\footnote{There is an
  additional assumption hidden here that $M$ does not depend on the
  complete-data parameters.}, we can break this up,
\begin{align}
  p(D^{\obs},M|\theta) = p(M|D^{\obs})p(D^{\obs}|\theta).
\end{align}
As we only care about inference on the complete data parameters, we can
write the likelihood as
\begin{align}
  L(\theta|D^{\obs}) &\propto p(D^{\obs}|\theta), 
\end{align}
which we can rewrite using the law of iterated expectations as
\begin{align}
  p(D^{\obs}|\theta) &= \int p(D|\theta) dD^{\mis}.
\end{align}
With this likelihood and a flat prior on $\theta$, we can see that the
posterior is 
\begin{equation}
  p(\theta | D^{\obs}) \propto p(D^{\obs}|\theta) = \int p(D|\theta)
  dD^{\mis}. 
\end{equation}
The main computational difficulty in the analysis of incomplete data
is taking draws from this posterior. The EM algorithm
\citep*{DemLaiRub77} is a simple computational approach to finding the
mode of the posterior. Our EMB algorithm combines the classic EM
algorithm with a bootstrap approach to take draws from this posterior.
For each draw, we bootstrap the data to simulate estimation
uncertainty and then run the EM algorithm to find the mode of the
posterior for the bootstrapped data, which gives us fundamental
uncertainty too (see \citet{HonKin09} for details of the EMB
algorithm).

Once we have draws of the posterior of the complete-data parameters,
we make imputations by drawing values of $D^{\mis}$ from its
distribution conditional on $D^{\obs}$ and the draws of $\theta$,
which is a linear regression with parameters that can be calculated
directly from $\theta$.

\subsection{Analysis}

In order to combine the results across $m$ data sets, first decide on
the quantity of interest to compute, such as univariate mean,
regression coefficient, predicted probability, or first difference.
Then, the easiest way is to draw $1/m$ simulations of $q$ from each of
the $m$ data sets, combine them into one set of $m$ simulations, and
then to use the standard simulation-based methods of interpretation
common for single data sets \citep{KinTomWit00}.

Alternatively, you can combine directly and use as the multiple
imputation estimate of this parameter, $\bar{q}$, the average of the
$m$ separate estimates, $q_j$ $(j=1,\dots,m)$:
\begin{equation}
  \bar{q}=\frac{1}{m}\sum^{m}_{j=1}q_j.  
\end{equation}

The variance of the point estimate is the average of the estimated
variances from \emph{within} each completed data set, plus the sample
variance in the point estimates \emph{across} the data sets
(multiplied by a factor that corrects for the bias because
$m<\infty$).  Let $SE(q_j)^2$ denote the estimated variance (squared
standard error) of $q_j$ from the data set $j$, and
$S^{2}_{q}=\Sigma^{m}_{j=1}(q_j-\bar{q})^2/(m-1)$ be the sample
variance across the $m$ point estimates.  The standard error of the
multiple imputation point estimate is the square root of
\begin{equation}
SE(q)^2=\frac{1}{m}\sum^{m}_{j=1}SE(q_j)^2+S^2_q(1+1/m).
\end{equation}

\section{Versions of \Amelia\ }

\label{sec:versions}
Two versions of \AmeliaII\ are available, each with its own advantages
and drawbacks, but both of which use the same underyling code.  First,
\AmeliaII\ exists as a package for the \R\ statistical software
package.  Users can utilize their knowledge of the \R\ language to run
\AmeliaII\ at the command line or to create scripts that will run
\AmeliaII\ and preserve the commands for future use.  Alternatively,
you may prefer \AmeliaView, where a interactive Graphical User
Interface (GUI) allows you to set options and run \Amelia\ without any
knowledge of the \R\ programming language.

Both versions of \AmeliaII\ are available on the Windows, Mac OS X,
and Linux platforms and \AmeliaII\ for \R\ runs in any environment that \R\
can.  All versions of \Amelia\ require the \R\ software, which
is freely available at \url{http://www.r-project.org/}.


\section{Installation and Updates}
\label{sec:install}

Before installing \AmeliaII, you must have installed \R\ version 2.1.0
or higher, which is freely available at
\url{http://www.r-project.org/}.

To install the \Amelia\ package on any platform, simply type the following at
the \R\ command prompt,
\begin{verbatim}
> install.packages("Amelia")
\end{verbatim}
and \R\ will automatically install the package to your system from CRAN. If
you wish to use the most current beta version of \Amelia\, feel free to
install the test version,
\begin{verbatim}
> install.packages("Amelia", repos = "http://gking.harvard.edu")
\end{verbatim}

In order to keep your copy of \Amelia\ completely up to date, you should
use the command
\begin{verbatim}
> update.packages()
\end{verbatim}


\subsection{Windows --- \AmeliaView}
\label{sec:win-install}
To install a standalone version of \AmeliaView\ in the Windows environment,
simply download the installer \texttt{setup.exe} from
\url{http://gking.harvard.edu/amelia/} and run it.  The installer will ask
you to choose a location to install \AmeliaII.  If you have installed \R\ 
with the default options, \AmeliaII\ will automatically find the location
of \R.  If the installer cannot find \R, it will ask you to locate the
directory of the most current version of \R.  Make sure you choose the
directory name that includes the version number of \R\ (e.g. C:/Program
Files/R/R-2.9.0) and contains a subdirectory named \texttt{bin}.  The
installer will also put shortcuts on your Desktop and Start Menu.

Even users familiar with the \R\ language may find it useful to
utilize \AmeliaView\ to set options on variables, change arguments, or
run diagnostics.  From the command line, \AmeliaView\ can be brought up
with the call:
\begin{verbatim}
> library(Amelia)
> AmeliaView()
\end{verbatim}


\subsection{Linux (local installation)}
\label{sec:lin-install}
Installing \Amelia\ on a Linux system is slightly more complicated due to
user permissions. If you are running \R\ with root access, you can simply
run the above installation procedure. If you do not have root access, you
can install \Amelia\ to a local library. First, create a local directory to
house the packages,
\begin{verbatim}
w4:mblackwell [~]: mkdir ~/myrlibrary
\end{verbatim}
and then, in an \R\ session, install the package directing \R\ to this
location:

\begin{verbatim}
> install.packages("Amelia", lib = "~/myrlibrary")
\end{verbatim}

Once this is complete you need to edit or create your \R\ profile.
Locate or create \texttt{\~/.Rprofile} in your home directory and add
this line:
\begin{verbatim}
.libPath("~/myrlibrary")
\end{verbatim}
This will add your local library to the list of library paths that \R\ 
searches in when you load libraries.

Linux users can use \AmeliaView\ in the same way as Windows users of
\Amelia\ for \R.  From the command line, \AmeliaView\ can be brought up
with the call:
\begin{verbatim}
> AmeliaView()
\end{verbatim}



\section{A User's Guide}
\label{sec:guide}

\subsection{Data and Initial Results}

We now demonstrate how to use \Amelia\ using data from \citet{MilKub05}
which studies the effect of democracy on trade policy. For the purposes of
this user's guide, we will use a subset restricted to nine developing
countries in Asia from 1980 to 1999\footnote{We have artificially added
  some missingness to these data for presentational purposes. You can
  access the original data at
  \url{http://www.princeton.edu/~hmilner/Research.htm}}. This dataset
includes 9 variables: year (\code{year}), country (\code{country}),
average tariff rates (\code{tariff}), Polity IV score\footnote{The Polity score
  is a number between -10 and 10 indicating how democratic a country is. A
  fully autocratic country would be a -10 while a fully democratic country
  would be 1 10.} (\code{polity}), total population (\code{pop}), gross
domestic product per capita (\code{gdp.pc}), gross international reserves
(\code{intresmi}), a dummy variable for if the country had signed an IMF
agreement in that year (\code{signed}), a measure of financial openness
(\code{fivop}), and a measure of US hegemony\footnote{This measure of US
  hegemony is the US imports and exports as a percent of the world total
  imports and exports.} (\code{usheg}). These variables correspond to the
variables used in the analysis model of \citet{MilKub05} in table 2.  

<<echo=FALSE, print=FALSE>>=
options("digits"=4)
options("width"=70)
options("show.signif.stars" = FALSE)
set.seed(12345)
@

We first load the \Amelia\ and the data:

<<echo=TRUE, print=FALSE>>=
require(Amelia)
data(freetrade)
@

We can check the summary statistics of the data to see that there is
missingness on many of the variables:

<<<echo=TRUE, print=TRUE>>=
summary(freetrade)
@ 

In the presence of missing data, most statistical packages use
\emph{listwise deletion}, which removes any row that contains a missing
value from the analysis. Using the base model of \citet{MilKub05} table 2,
we run a simple linear model in \R, which uses listwise deletion:
<<echo=TRUE, print=TRUE>>=
summary(lm(tariff ~ polity + pop + gdp.pc + year + country, 
          data = freetrade)) 
@ 

Note that 60 of the 171 original observations are deleted due to
missingness. Most of these observations, however, have information in them
and multiple imputation will help us retrieve that information and make
better inferences.

\subsection{Multiple Imputation}


When performing multiple imputation, the first step is to identify the
variables to include in the model.  It is crucial to include at least
as much information as in the analysis model. That is, any variable
that will be in the analysis model should also be in the imputation
model. In fact, it is often useful to add more information. Since
imputation is predictive, any variables that would increase predictive
power should be included in the model, even if including them in the
analysis model would produce bias (such as for post-treatment
variables). In our case, we include all the variables in
\code{freetrade} in the imputation model, even though we our analysis
model focuses on \code{polity}, \code{pop} and
\code{gdp.pc}\footnote{Note that this specification does not utilize
  time or spatial data yet. The \texttt{ts} and \texttt{cs} arguments
  only have force when we also include \texttt{polytime} or
  \texttt{intercs}, discussed in section \ref{sec:tscs}}.

To create multiple imputations in \Amelia, we can simply run 
<<echo=TRUE, print=FALSE>>=
a.out <- amelia(freetrade, m = 5, ts = "year", cs = "country")
a.out
@ 

The output gives some information about how the algorithm ran. Each of the
imputed datasets is now in the list \code{a.out\$imputations}.  Thus, we
could plot a histogram of the \code{tariff} variable from the 3rd
imputation,

<<label=hist1plot, include=FALSE>>=
hist(a.out$imputations[[3]]$tariff, col="grey", border="white")
@



<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,1))))
@ 

\begin{figure} 
\begin{center}   
<<label=hist1, fig=TRUE, echo=FALSE, width=7, height=7>>=
<<hist1plot>>
@
  
\caption{Histogram of the \texttt{tariff} variable from the 3rd imputated dataset.}
\label{fig:hist1}
\end{center}
\end{figure}

\subsubsection{Saving imputed datasets}
\label{sec:saving}
If you need to save your imputed datasets, you can either save the output
from \code{amelia},

\begin{verbatim}
> save(a.out, file = "imputations.RData")
\end{verbatim}

In addition, you can save each of the imputed datasets to its own file
using the \code{write.amelia} command,
\begin{verbatim}
> write.amelia(obj=a.out, file.stem = "outdata")
\end{verbatim}
This will create one comma-separated value file for each imputed dataset
in the following manner:
\begin{verbatim}
outdata1.csv
outdata2.csv
outdata3.csv
outdata4.csv
outdata5.csv
\end{verbatim}
The \code{write.amelia} function can also save files in tab-delimited and
Stata (\code{.dta}) file formats. For instance, to save Stata files,
simply change the \code{format} argument to \code{"dta"},

\begin{verbatim}
> write.amelia(obj=a.out, file.stem = "outdata", format = "dta")
\end{verbatim}

\subsubsection{Combining Multiple \Amelia\ Runs}
The EMB algorithm is what computer scientists call \emph{embarrassingly
  parallel}, meaning that it is simple to separate each imputation into
parallel processes. With \Amelia\ it is simple to run subsets of the
imputations on different machines and then combine them after the
imputation for use in analysis model. This allows for a huge increase in
the speed of the algorithm. 

For instance, suppose that we wanted to add another ten imputated datasets
to my first call to \texttt{amelia}. First, run the function to get
these additional imputations,
<<>>=
a.out.more <- amelia(freetrade, m = 10, ts = "year", cs = "country", p2s=0)
a.out.more
@ 
then combine this output with our original output using the
\code{ameliabind} function,
<<>>=
a.out.more <- ameliabind(a.out, a.out.more)
a.out.more
@ 
This function binds the two outputs into the same output so that you can
pass the combined imputations easily to analysis models and
diagnostics. Note that \code{a.out.more} now has a total of 15
imputations. 

A simple way to execute a parallel processing scheme with \Amelia\ would
be to run \code{amelia} with \code{m} set to 1 on $m$ different machines,
save each output using the \code{save} function, load them all on the same
\R\ session using \code{load} command and then combine them using
\code{ameliabind}. In order to do this, however, make sure to name each of
the outputs a different name so that they do not overwrite each other when
loading into the same \R\ session. 

\subsubsection{Screen Output}
Screen output can be adjusted with the ``print to screen'' argument,
\code{p2s}.  At a value of 0, no screen printing will occur.  This may be
useful in large jobs or simulations where a very large number of
imputation models may be required.  The default value of 1, lists each
bootstrap, and displays the number of iterations required to reach
convergence in that bootstrapped dataset.  The value of 2 gives more
thorough screen output, including, at each iteration, the number of
parameters that have significantly changed since the last iteration. This
may be useful when the EM chain length is very long, as it can provide an
intuition for many parameters still need to converge in the EM chain, and
a sense of the time remaining.  However, it is worth noting that the last
several parameters can often take a significant fraction of the total
number of iterations to converge.  Setting \code{p2s} to 2 will also
generate information on how EM algorithm is behaving, such as a \code{!}
when the current estimated complete data covariance matrix is not
invertible and a \code{*} when the likelihood has not monotonically
increased in that step. Having many of these two symbols in the screen
output is an indication of a problematic imputation
model\footnote{Problems of non-invertible matrices often mean that current
  guess for the covariance matrix is singular. This is a sign that there
  may be two highly correlated variables in the model. One way to resolve
  is to use a ridge prior (see \ref{sec:prior})}.

An example of the output when \code{p2s} is 2 would be 

<<echo=TRUE, print=FALSE>>=
amelia(freetrade, m = 1, ts = "year", cs = "country", p2s = 2)
@ 

\subsection{Imputation-improving Transformations}
\label{sec:trans}

Social science data commonly includes variables that fail to fit to
a multivariate normal distribution. Indeed, numerous models have been
introduced specifically to deal with the problems they present.  As it
turns out, much evidence in the literature (discussed in
\citealt{KinHonJos01}) indicates that the multivariate normal model
used in \Amelia\ usually works well for the imputation
stage even when discrete or non-normal variables are included and when
the analysis stage involves these limited dependent variable models.
Nevertheless, \Amelia\ includes some limited capacity to
deal directly with ordinal and nominal variables and to variables that
require other transformations.  In general nominal and log transform
variables should be declared to \Amelia, whereas ordinal (including
dichotomous) variables often need not be, as described below.  (For
harder cases, see \citep{Schafer97}, for specialized MCMC-based imputation
models for discrete variables.)\nocite{KinHonJos01}

Although these transformations are taken internally on these variables
to better fit the data to the multivariate normal assumptions of the
imputation model, all the imputations that are created will be
returned in the original untransformed form of the data.  If the user
has already performed transformations on their data (such as by taking
a log or square root prior to feeding the data to \code{amelia}) these
do not need to be declared, as that would result in the transformation
occurring \emph{doubly} in the imputation model.  The fully imputed
data sets that are returned will always be in the form of the original
data that is passed to the \code{amelia} routine.

\subsubsection{Ordinal}
\label{sec:ord}
In much statistical research, researchers treat independent ordinal
(including dichotomous) variables as if they were really continuous.
If the analysis model to be employed is of this type, then nothing
extra is required of the of the imputation model. Users are advised to
allow \Amelia\ to impute non-integer values for any
missing data, and to use these non-integer values in their analysis.
Sometimes this makes sense, and sometimes this defies intuition. One
particular imputation of 2.35 for a missing value on a seven point
scale carries the intuition that the respondent is between a 2 and a 3
and most probably would have responded 2 had the data been observed.
This is easier to accept than an imputation of 0.79 for a dichotomous
variable where a zero represents a male and a one represents a female
respondent. However, in both cases the non-integer imputations carry
more information about the underlying distribution than would be
carried if we were to force the imputations to be integers. Thus
whenever the analysis model permits, missing ordinal observations
should be allowed to take on continuously valued imputations.

In the \code{freetrade} data, one such ordinal variable is \code{polity}
which ranges from -10 (full autocracy) to 10 (full democracy). If we
tabulate this variable from one of the imputed datasets, 


<<echo=TRUE, print=TRUE>>=
table(a.out$imputations[[3]]$polity)
@ 
we can see that there is one imputation between -4 and -3 and one
imputation between 6 and 7. Again, the interpretation of these values is
rather straightforward even if they are not strictly in the coding of the
original Polity data. 

Often, however, analysis models require some variables to be strictly
ordinal, as for example the dependent variable must be in a logistical or
Poisson regression.  Imputations for variables set as ordinal are created
by taking the continuously valued imputation and using an appropriately
scaled version of this as the probability of success in a binomial
distribution. The draw from this binomial distribution is then translated
back into one of the ordinal categories.

For our data we can simply add \code{polity} to the \code{ords} argument:
<<echo=TRUE, print=FALSE>>=
a.out1 <- amelia(freetrade, m = 5, ts = "year", cs = "country", ords =
                 "polity", p2s = 0)
table(a.out1$imputations[[3]]$polity)
@ 
Now, we can see that all of the imputations fall into one of the original
polity categories. 

\subsubsection{Nominal}
\label{sec:nom}
Nominal variables\footnote{Dichotomous (two category) variables are a
  special case of nominal variables. For these variables, the nominal and
  ordinal methods of transformation in \Amelia\ agree.} must be treated
quite differently than ordinal variables. Any multinomial variables in the
data set (such as religion coded 1 for Catholic, 2 for Jewish, and 3 for
Protestant) must be specified to \Amelia. In our
\texttt{freetrade} dataset, we have \texttt{signed} which is 1 if a country
signed an IMF agreement in that year and 0 if it did not. Of course, our
first imputation did not limit the imputations to these two categories

<<>>=
table(a.out1$imputations[[3]]$signed)
@ 

In order to fix this for a $ p$-category multinomial variable,\Amelia\ will
determine $ p$ (as long as your data contain at least one value in each
category), and substitute $ p-1$ binary variables to specify each possible
category. These new $ p-1$ variables will be treated as the other
variables in the multivariate normal imputation method chosen, and receive
continuous imputations. These continuously valued imputations will then be
appropriately scaled into probabilities for each of the $ p$ possible
categories, and one of these categories will be drawn, where upon the
original $ p$-category multinomial variable will be reconstructed and
returned to the user. Thus all imputations will be appropriately
multinomial.


For our data we can simply add \code{signed} to the \code{noms} argument:
<<echo=TRUE, print=FALSE>>=
a.out2 <- amelia(freetrade, m = 5, ts = "year", cs = "country", noms =
                 "signed", p2s = 0)
table(a.out2$imputations[[3]]$signed)
@ 
Note that \Amelia\ can only fit imputations into categories that exist in
the original data. Thus, if there was a third category of signed, say 2,
that corresponded to a different kind of IMF agreement, but it never
occurred in the original data, \Amelia\ could not match imputations to it. 

Since \Amelia\ properly treats a $ p$-category multinomial
variable as $ p-1$ variables, one should understand the number of
parameters that are quickly accumulating if many multinomial variables
are being used. If the square of the number of real and constructed
variables is large relative to the number of observations, it is useful to
use a ridge prior as in section \ref{sec:prior}.

\subsubsection{Natural Log}
\label{sec:log}
If one of your variables is heavily skewed or has outliers that may
alter the imputation in an unwanted way, you can use a natural
logarithm transformation of that variable in order to normalize its
distribution.  This transformed distribution helps \Amelia\ 
to avoid imputing values that depend too heavily on outlying data
points.  Log transformations are common in expenditure and economic
variables where we have strong beliefs that the marginal relationship
between two variables decreases as we move across the range.

For instance, figure \ref{fig:logshist} show the \code{tariff} variable
clearly has positive (or, right) skew while its natural log transformation
has a roughly normal distribution. 

<<label=logshist, include=FALSE, echo=FALSE>>=
hist(freetrade$tariff, col="grey", border="white")
hist(log(freetrade$tariff), col="grey", border="white")
@

<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,2))))
@ 

\begin{figure} 
\begin{center}  
<<label=hist2, fig=TRUE, echo=FALSE, eps=FALSE, width=10, height=6>>=
<<logshist>>
@
\caption{Histogram of \texttt{tariff} and \texttt{log(tariff)}.}
\label{fig:logshist}
\end{center}
\end{figure}


<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,1))))
@ 

\subsubsection{Square Root}
\label{sec:sqrt}
Event count data is often heavily skewed and has nonlinear
relationships with other variables.  One common transformation to
tailor the linear model to count data is to take the square roots of
the counts.  This is a transformation that can be set as an option in
\Amelia.
 
\subsubsection{Logistic}
\label{sec:lgstc}
Proportional data is sharply bounded between 0 and 1.  A logistic
transformation is one possible option in \Amelia\ to make the
distribution symmetric and relatively unbounded.

\subsection{Identification Variables}
\label{sec:idvars}
Datasets often contain identification variables, such as country
names, respondent numbers, or other identification numbers, codes or
abbreviations.  Sometimes these are text and sometimes these are
numeric.  Often it is not appropriate to include these variables in
the imputation model, but it is useful to have them remain in the
imputed datasets (However, there are models that would include the ID
variables in the imputation model, such as fixed effects model for
data with repeated observations of the same countries).
Identification variables which are not to be included in the
imputation model can be identified with the argument \code{idvars}.
These variables will not be used in the imputation model, but will be
kept in the imputed datasets.

If the \code{year} and \code{country} contained no information except
labels, we could omit them from the imputation:

<<results = hide>>=
amelia(freetrade, idvars = c("year", "country"))
@ 
Note that Amelia will return with an error if your dataset contains a
factor or character variable that is not marked as a nominal or
identification variable. Thus, if we were to omit the factor
\code{country} from the \code{cs} or \code{idvars} arguments, we would
receive an error:
<<>>=
a.out2 <- amelia(freetrade, idvars = c("year"))
@ 

In order to conserve memory, it is wise to remove unnecessary
variables from a data set before loading it into \Amelia.
The only variables you should include in your data when running
\Amelia\ are variables you will use in the analysis stage
and those variables that will help in the imputation model.  While it
may be tempting to simply mark unneeded variables as IDs, it only
serves to waste memory and slow down the imputation procedure.
 
\subsection{Time Series, or Time Series Cross Sectional Data} \label{sec:tscs}

Many variables that are recorded over time within a cross-sectional unit
are observed to vary smoothly over time.  In such cases, knowing the
observed values of observations close in time to any missing value may
enormously aid the imputation of that value.  However, the exact pattern
may vary over time within any cross-section.  There may be periods of
growth, stability, or decline; in each of which the observed values would
be used in a different fashion to impute missing values.  Also, these
patterns may vary enormously across different cross-sections, or may exist
in some and not others.  \Amelia\ can build a general model of patterns
within variables across time by creating a sequence of polynomials of the
time index.  If, for example, tariffs vary smoothly over time, then we
make the modeling assumption that there exists some polynomial that
describes the economy in cross-sectional unit $i$ at time $t$ as:
\begin{equation}
\textrm{tariff}_{ti} = \beta_0 + \beta_1 t + \beta_1 t^2 + \beta_1 t^3 \ldots
\end{equation}
And thus if we include enough higher order terms of time then the pattern
between observed values of the tariff rate can be estimated.  \Amelia\
will create polynomials of time up to the user defined $k$-th order,
($k\leq3$).

We can implement this with the \code{ts} and \code{polytime} arguments. If
we thought that a second-order polynomial would help predict we could run
<<results = hide>>=
a.out2 <- amelia(freetrade, ts = "year", cs = "country", polytime = 2)
@ 
With this input, \Amelia\ will add covariates to the model that correspond
to time and its polynomials. These covariates will help better predict the
missing values. 

If cross-sectional units are specified these polynomials can be interacted
with the cross-section unit to allow the patterns over time to vary
between cross-sectional units.  Unless you strongly believe all units have
the same patterns over time in all variables (including the same constant
term), this is a reasonable setting.  When $k$ is set to 0, this
interaction simply results in a model of \emph{fixed effects} where every
unit has a uniquely estimated constant term.  \Amelia\ does not smooth
the observed data, and only uses this functional form, or one you choose,
with all the other variables in the analysis and the uncertainty of the
prediction, to impute the missing values.

The above code would predict the same trend in a variable for each
country. It is clear, however, that each country will have a different
time series for tariff rates, for instance. Some countries may start
higher than other or possibly some countries dropped dramatically while
other remained fairly constant over time. In order to capture this in the
style above, we can set \code{intercs} to \code{TRUE}:

<<echo=TRUE, results = hide>>=
a.out.time <- amelia(freetrade, ts = "year", cs = "country", polytime = 2,
                 intercs = TRUE, p2s = 2)
@

Note that attempting to use \code{polytime} without the \code{ts}
argument, or \code{intercs} without the \code{cs} argument will result in
an error. 

Using the \code{tscsPlot} function (discussed below), we can see in figure
\ref{fig:tcomp} that we have a much better prediction about the missing
values when incorporating time than when we omit it:

<<tcomp1, include = FALSE>>=
tscsPlot(a.out, cs = "Malaysia", main = "Malaysia (no time settings)", 
         var = "tariff", ylim = c(-10, 60))

tscsPlot(a.out.time, cs = "Malaysia", main = "Malaysia (with time settings)", 
         var = "tariff", ylim = c(-10, 60))
@ 


<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,2))))
@ 
\begin{figure}
\begin{center}
<<label = timecompare, echo=FALSE, fig=TRUE, eps=FALSE, width=10, height=6>>=
<<tcomp1>>
@
\caption{The increase in predictive power when using polynomials of
      time. The panels shows mean imputations with 95\% bands (in red) and
    observed data point (in black). The left panel shows an imputation
    without using time and the right panel includes polynomials of time.}
  \label{fig:tcomp}
  \end{center}
\end{figure}

\subsubsection{Lags and Leads}
\label{sec:lags}

An alternative way of handling time-series information is to include lags
and leads of certain variables into the imputation model. \emph{Lags} are
variables that take the value of another variable in the previous time
period while \emph{leads} take the value of another variable in the next
time period. Many analysis models use lagged variables to deal with issues
of endogeneity, thus using leads may seems strange. It is important to
remember, however, that imputation models are predictive, not causal.
Thus, since both past and future values of a variable are likely
correlated with the present value, both lags and leads should improve the
model.

If we wanted to include lags and leads of tariffs, for instance, we would
simply pass this to the \code{lags} and \code{leads} arguments:

<<results = hide>>=
a.out2 <- amelia(freetrade, ts = "year", cs = "country", lags = "tariff",
                 leads = "tariff")
@ 


\subsection{Including Prior Information} 

\Amelia\ has a number of methods of setting priors within the imputation
model.  Two of these are commonly used and discussed below, ridge priors
and observational priors.

\subsubsection{Ridge Priors for High Missingness, Small $n$'s, or Large Correlations}
\label{sec:prior}

When the data to be analyzed contain a high degree of missingness or
very strong correlations among the variables, or when the number of
observations is only slightly greater than the number of parameters
$p(p+3)/2$ (where $p$ is the number of variables), results from your
analysis model will be more dependent on the choice of imputation
model.  This suggests more testing in these cases of alternative
specifications under \Amelia. This can happen when using the
polynomials of time interacted with the cross section are included in the
imputation model. In our running example, we used a polynomial of degree
2 and there are 9 countries. This adds $3 \times 9 = 18$ more variables to
the imputation model. When these are added, the EM algorithm can become
unstable, as indicated by the differing chain lengths for each imputation:
<<>>=
a.out.time
@ 

In these circumstances, we recommend adding a ridge prior which will help
with numerical stability by shrinking the covariances among the variables
toward zero without changing the means or variances. This can be done by
including the \code{empri} argument. Including this prior as a positive
number is roughly equivalent to adding \code{empri} artificial
observations to the data set with the same means and variances as the
existing data but with zero covariances.  Thus, increasing the
\code{empri} setting results in more shrinkage of the covariances, thus
putting more a priori structure on the estimation problem: like many
Bayesian methods, it reduces variance in return for an increase in bias
that one hopes does not overwhelm the advantages in efficiency.  In
general, we suggest keeping the value on this prior relatively small and
increase it only when necessary.  A recommendation of 0.5 to 1 percent of
the number of observations, $n$, is a reasonable starting value, and often
useful in large datasets to add some numerical stability.  For example, in
a dataset of two thousand observations, this would translate to a prior
value of 10 or 20 respectively.  A prior of up to 5 percent is moderate in
most applications.

For our data, it is easy to code up a 1 percent ridge prior:
<<>>=
a.out.time2 <- amelia(freetrade, ts = "year", cs = "country", polytime = 2,
                 intercs = TRUE, p2s = 0, empri = .01*nrow(freetrade))
a.out.time2
@ 
This new imputation model is much more stable and, as shown by using
\code{tscsPlot}, produces about the same imputations as the original
model (see figure \ref{fig:tcomp2}):
<<tcomp2, include = FALSE>>=
tscsPlot(a.out.time, cs = "Malaysia", main = "Malaysia (no ridge prior)", 
         var = "tariff", ylim = c(-10, 60))

tscsPlot(a.out.time2, cs = "Malaysia", main = "Malaysia (with ridge prior)", 
         var = "tariff", ylim = c(-10, 60))
@ 

<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,2))))
@ 

\begin{figure}
  \begin{center}
<<label = timecomp2, echo=FALSE, fig=TRUE, eps=FALSE, width=10, height=6>>=
<<tcomp2>>
@
    \caption{The difference in imputations when using no ridge prior
      (left) and when using a ridge prior set to 1\% of the data (right).}
  \label{fig:tcomp2}
  \end{center}
\end{figure}


\subsubsection{Observation-level priors}
\label{sec:obspri}

Researchers often have additional prior information about missing data 
values based on previous research, academic consensus, or personal 
experience.  \Amelia\ can incorporate this information to produce vastly 
improved imputations.  The \Amelia\ algorithm allows users to include 
informative Bayesian priors about individual missing data cells 
instead of the more general model parameters, many of which have 
little direct meaning.  

The incorporation of priors follows basic Bayesian analysis where the
imputation turns out to be a weighted average of the model-based
imputation and the prior mean, where the weights are functions of the
relative strength of the data and prior: when the model predicts very
well, the imputation will down-weight the prior, and vice versa
\citep{HonKin09}.

The priors about individual observations should describe the analyst's
belief about the distribution of the missing data cell.  This can either
take the form of a mean and a standard deviation or a confidence interval.
For instance, we might know that 1986 tariff rates in Thailand around
$40\%$, but we have some uncertainty as to the exact value.  Our prior
belief about the distribution of the missing data cell, then, centers on
$40$ with a standard deviation that reflects the amount of uncertainty we
have about our prior belief.

To input priors you must build a priors matrix with either four or five
columns. Each row of the matrix represents a prior on either one
observation or one variable.  In any row, the entry in the first column is
the row of the observation and the entry is the second column is the
column of the observation.  In the four column priors matrix the third and
fourth columns are the mean and standard deviation of the prior
distribution of the missing value.  

For instance, suppose that we had some expert prior information about
tariff rates in Thailand. We know from the data that Thailand is missing
tariff rates in many years, 

<<>>=
freetrade[freetrade$country == "Thailand", c("year","country","tariff")]
@  

%% this is here to fix mb's syntax highlighting
<<eval=FALSE>>=
#$
@ 

Suppose that we had expert information that tariff rates were roughly 40\%
in Thailand between 1986 and 1988 with about a 6\% margin of error.  This
corresponds to a standard deviation of aobut 3. In order to include this
information, we must form the priors matrix:

<<>>=
pr <- matrix(c(158,159,160,3,3,3,40,40,40,3,3,3), nrow=3, ncol=4) 
pr
@

The first column of this matrix corresponds to the row numbers of Thailand
in these three years, the second column refers to the column number of
\code{tariff} in the data and the last two columns refer to the actual
prior. Once we have this matrix, we can pass it to \code{amelia},
<<results = hide>>=
a.out.pr <- amelia(freetrade, ts = "year", cs = "country", priors = pr)
@ 

In the five column matrix, the last three columns describe a confidence
range of the data. The columns are a lower bound, an upper bound, and a
confidence level between 0 and 1, exclusive.  Whichever format you choose,
it must be consistent across the entire matrix.  We could get roughly the
same prior as above by utilizing this method. Our margin of error implies
that we would want imputations between 34 and 46, so our matrix would be
<<>>=
pr.2 <- matrix(c(158,159,160,3,3,3,34,34,34,46,46,46,.95,.95,.95), nrow=3, ncol=5)
pr.2
@
These priors indicate that we are 95\% confident that these missing values
are in the range 34 to 46. 

If a prior has the value 0 in the first column, this prior will be applied
to all missing values in this variable, except for explitictly set priors.
Thus, we could set a prior for the entire \code{tariff} variable of 20,
but still keep the above specific priors with the following code:


<<>>=
pr.3 <- matrix(c(158,159,160,0,3,3,3,3,40,40,40,20,3,3,3,5), nrow=4, ncol=4)
pr.3
@ 

%% add section on bounds, get rid of sessions, etc. 

\subsubsection{Logical bounds}

In some cases, variables in the social sciences have known logical
bounds. Proportions must be between 0 and 1 and duration data
must be greater than 0, for instance. Many of these logical bounds can be
handled by the proper transformation (see \ref{sec:trans} for more details
on the transformations handled by \Amelia). In the rare case that
imputations must satisfy certain logical bounds not handled by these
transformations, \Amelia\ can take draws from a truncated normal
distribution in order to achieve imputations that satisfy the
bounds. Note, however, that this procedure imposes extrememly strong
restrictions on the imputations and can lead to lower variances than the
imputation model implies. In general, building a more predictive
imputation model will lead to better imputations than imposing these bounds.

\Amelia\ implements these bounds by rejection sampling. When drawing the
imputations from their posterior, we repeatedly resample until we have a
draw that satisfies all of the logical constraints. You can set an upper
limit on the number of times to resample with the \code{max.resample}
arguments. Thus, if after \code{max.resample} draws, the imputations are
still outside the bounds, \Amelia\ will set the imputation at the edge of
the bounds. Thus, if the bounds were 0 and 100 and all of the draws were
negative, \Amelia\ would simply impute 0.

As an extreme example, suppose that we know, for certain that tariff rates
had to fall between 30 and 40. This, obviously, is not true, but we can
generate imputations from this model. In order to specify these bounds, we
need to generate a matrix of bounds to pass to the \code{bounds}
argument. This matrix will have 3 columns: the first is the column for the
bounded variable, the second is the lower bound and the third is the upper
bound. Thus, to implement our bound on tariff rates (the 3rd column of the
dataset), we would create the matrix,

<<>>=
bds <- matrix(c(3, 30, 40), nrow = 1, ncol = 3)
bds
@ 

which we can pass to the \code{bounds} argument,

<<>>=
a.out.bds <- amelia(freetrade, ts = "year", cs = "country", bounds = bds,
                    max.resample = 1000)
@ 

The difference in results between the bounded and unbounded model are not
obvious from the output, but inspection of the imputed tariff rates for
Malaysia in figure \ref{fig:bcomp} shows that there has been a drastic
restriction of the imputations to the desired range:


<<bounds, include=FALSE>>=
tscsPlot(a.out, cs = "Malaysia", main = "No logical bounds", var =
         "tariff", ylim = c(-10,60))

tscsPlot(a.out.bds, cs = "Malaysia", main = "Bounded between 30 and 40", var =
         "tariff", ylim = c(-10,60))
@ 

Again, analysts should be extremely cautious when using these bounds as
they can seriously affect the inferences from the imputation model, as
shown in this example. Even when logical bounds exist, we recommend simply
imputing variables normally, as the violation of the logical bounds
represents part of the true uncertainty of imputation. 

<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,2))))
@ 

\begin{figure}
  \begin{center}
<<label = boundscomp, echo=FALSE, fig=TRUE, eps=FALSE, width=10, height=6>>=
<<bounds>>
@
    \caption{On the left are the original imputations without logical
      bounds and on the right are the imputation after imposing the
      bounds.}
  \label{fig:bcomp}
  \end{center}
\end{figure}


\subsection{Diagnostics}\label{sec:diag}

\Amelia\ currently provides a number of diagnostic tools to inspect the
imputations that are created. 

\subsubsection{Comparing Densities}

One check on the plausibility of the imputaiton model is check the
distribution of imputed values to the distribution of observed values.
Obviously we cannot expect, \emph{a priori}, that these distribution will
be identical as the missing values may differ systematically from the
observed value--this is whole reason to impute to begin with! Imputations
with strange distributions or those that are far from the observed data
may indicate that imputation model needs at least some investigation and
possibly some improvement. 

The \code{plot} method works on output from \code{amelia} and, by default,
shows for each variable a plot of the relative frequencies of the
observed data with an overlay of the relative frequency of the imputed
values.
<<plotmeth, include = FALSE>>=
plot(a.out, which.vars = 3:6)
@ 
where the argument \code{which.vars} indicates which of the variables to
plot (in this case, we are taking the 3rd through the 6th variables). 

\begin{figure}
  \begin{center}
<<plot1, echo=FALSE, fig=TRUE, eps=FALSE, height = 7, width = 7>>=
<<plotmeth>>
@ 
\caption{The output of the \texttt{plot} method as applied to output from
  \texttt{amelia}. In the upper panels, the distribution of mean imputations
  (in red) is overlayed on the distribution of observed values (in black)
  for each variable. In the lower panels, there are no missing values and
  the distribution of observed values is simply plotted (in blue). Note
  that how imputed tariff rates are very similar to observed tariff rates,
  but the imputation of the Polity score are quite different. This is
  plausible if different types of regimes tend to be missing at different
  rates.}
\end{center}
\end{figure}

The imputed curve (in red) plots the density of the \emph{mean} imputation
over the $m$ datasets.  That is, for each cell that is missing in the
variable, the diagnostic will find the mean of that cell across each of
the $m$ datasets and use that value for the density plot. The black
distributions are the those of the observed data.  When variables are
completely observed, their densities are plotted in blue. These graphs
will allow you to inspect how the density of imputations compares to the
density of observed data. Some discussion of these graphs can be found in
\citet*{AbaGelLev05}.  Minimally, these graphs can be used to check that
the mean imputation falls within known bounds, when such bounds exist in
certain variables or settings.

We can also use the function \code{compare.density} directly to make these
plots for an individual variable:

<<include=FALSE>>=
compare.density(a.out, var = "signed")
@ 

<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,1))))
@ 
\subsubsection{Overimpute}
\label{sec:overimpute}

\emph{Overimputing} is a technique we have developed to judge the fit
of the imputation model.  Because of the nature of the missing data
mechanism, it is impossible to tell whether the mean prediction of the
imputation model is close to the unobserved value that is trying to be
recovered.  By definition this missing data does not exist to create
this comparison, and if it existed we would no longer need the
imputations or care about their accuracy.  However, a natural question
the applied researcher will often ask is how accurate are these
imputed values?

Overimputing involves sequentially treating each of the
\emph{observed} values as if they had actually been missing.  For each
observed value in turn we then generate several hundred imputed values
of that observed value, \emph{as if it had been missing}.  While $m=5$
imputations are sufficient for most analysis models, this large number
of imputations allows us to construct a confidence interval of what
the imputed value would have been, had any of the observed data been
missing.  We can then graphically inspect whether our observed data
tends to fall within the region where it would have been imputed had
it been missing. 

For example, we can run the overimputation diagnostic on our data by
running
<<overimp, include=FALSE>>=
overimpute(a.out, var = "tariff")
@ 

<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,1))))
@ 

\begin{figure}[htp!]
  \begin{center}
<<oi2, echo=FALSE, fig=TRUE, eps=FALSE, width = 7, height = 7>>=
<<overimp>>
@
  \caption{An example of the overimputation diagnostic graph.  Here
    ninety percent confidence intervals are constructed that detail
    where an observed value would have been imputed had it been
    missing from the dataset, given the imputation model.  The dots
    represent the mean imputation.  Around ninety percent of these
    confidence intervals contain the $y=x$ line, which means that the
    true observed value falls within this range.  The color of the
    line (as coded in the legend) represents the fraction of missing
    observations in the pattern of missingness for that observation.}
  \label{f:oi2}
\end{center}
\end{figure}

Our overimputation diagnostic, shown in \ref{f:oi2}, runs this procedure
through all of the observed values for a user selected variable.  We can
graph the estimates of each observation against the true values of the
observation.  On this graph, a $y=x$ line indicates the line of perfect
agreement; that is, if the imputation model was a perfect predictor of the
true value, all the imputations would fall on this line.  For each
observation, \Amelia\ also plots 90\% confidence intervals that allows the
user to visually inspect the behavior of the imputation model. By checking
how many of the confidence intervals cover the $y=x$ line, we can tell how
often the imputation model can confidently predict the true value of the
observation.

\begin{figure}[htp!]
  \centering \includegraphics[scale=.8]{overimp}
  \caption{Another example of the overimpute diagnostic graph. Note that
    the red lines are those observations that have fewer covariates
    observed and have a higher variance in the imputation. }
  \label{f:oi}
\end{figure}
Occasionally, the overimputation can display unintuitive results.  For
example, different observations may have different numbers of observed
covariates.  If covariates that are useful to the prediction are
themselves missing, then the confidence interval for this observation
will be much larger.  In the extreme, there may be observations where
the observed value we are trying to overimpute is \emph{the only}
observed value in that observation, and thus there is nothing left to
impute that observation with when we pretend that it is missing, other
than the mean and variance of that variable.  In these cases, we
should correctly expect the confidence interval to be very large.

An example of this graph is shown in figure \ref{f:oi}.  In this
simulated bivariate dataset, one variable is overimputed and the
results displayed.  The second variable is either observed, in which
case the confidence intervals are very small and the imputations
(yellow) are very accurate, or the second variable is missing in which
case this variable is being imputed simply from the mean and variance
parameters, and the imputations (red) have a very large and
encompassing spread.  The circles represent the mean of all the
imputations for that value.  As the amount of missing information in a
particular pattern of missingness increases, we expect the width of
the confidence interval to increase.  The color of the confidence
interval reflects the percent of covariates observed in that pattern
of missingness, as reflected in the legend at the bottom.


\subsubsection{Overdispersed Starting Values}
\label{sec:overdisperse}

If the data given to \Amelia\ has a poorly behaved likelihood, the EM
algorithm can have problems finding a global maximum of the likelihood
surface and starting values can begin to effect imputations.  Because the
EM algorithm is deterministic, the point in the parameter space where you
start it can impact where it ends, though this is irrelevant when the
likelihood has only one mode.  However, if the starting values of an EM
chain are close to a local maximum, the algorithm may find this maximum,
unaware that there is a global maximum farther away.  To make sure that
our imputations do not depend on our starting values, a good test is to
run the EM algorithm from multiple, dispersed starting values and check
their convergence.  In a well behaved likelihood, we will see all of these
chains converging to the same value, and reasonably conclude that this is
the likely global maximum.  On the other hand, we might see our EM chain
converging to multiple locations.  The algorithm may also wander around
portions of the parameter space that are not fully identified, such as a
ridge of equal likelihood, as would happen for example, if the same
variable were accidentally included in the imputation model twice.

\Amelia\ includes a diagnostic to run the EM chain from multiple
starting values that are overdispersed from the estimated maximum.
The overdispersion diagnostic will display a graph of the paths of
each chain.  Since these chains move through spaces that are in an
extremely high number of dimensions and can not be graphically
displayed, the diagnostic reduces the dimensionality of the EM paths
by showing the paths relative to the largest principle components of
the final mode(s) that are reached.  Users can choose between graphing
the movement over the two largest principal components, or more simply
the largest dimension with time (iteration number) on the $x$-axis.
The number of EM chains can also be adjusted.  Once the diagnostic
draws the graph, the user can visually inspect the results to check
that all chains convergence to the same point.

For our original model, this is a simple call to \code{disperse}:

<<disp1d>>=
disperse(a.out, dims = 1, m = 5)
disperse(a.out, dims = 2, m = 5)
@ 

where \code{m} designates the number of places to start EM chains from and
\code{dims} are the number of dimensions of the principal components to
show. 

<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,2))))
@ 
\begin{figure}[ht]
  \begin{center}
<<disp1dfig, echo=FALSE, fig=TRUE, eps=FALSE, width=9, height=5.5>>=
<<disp1d>>
@
\label{f:overgood}
   \caption{A plot from the overdispersion diagnostic where all EM chains
     are converging to the same mode, regardless of starting value.  On
     the left, the $y$-axis represents movement in the (very high
     dimensional) parameter space, and the $x$-axis represents the
     iteration number of the chain. On the right, we visualize the
     parameter space in two dimensions using the first two principal
     components of the end points of the EM chains.  The iteration number
     is no longer represented on the $y$-axis, although the distance
     between iterations is marked by the distance between arrowheads on
     each chain.}
  \end{center}
\end{figure}

In one dimension, the diagnostic plots movement of the chain on the
$y$-axis and time, in the form of the iteration number, on the $x$-axis.
Figures \ref{f:overgood} show two examples of these plots.  The
first shows a well behaved likelihood, as the starting values all converge
to the same point.  The black horizontal line is the point where \Amelia\
converges when it uses the default method for choosing the starting
values.  The diagnostic takes the end point of this chain as the possible
maximum and disperses the starting values away from it to see if the chain
will ever finish at another mode.  

A few of the iterations of this diagnostic can ending up in vastly
different locations of the parameter space.  This can happen for a variety
of reasons.  For instance, suppose that we created another dataset and
accidently included a linear function of another variable in this dataset:

<<>>=
freetrade2 <- freetrade
freetrade2$tariff2 <- freetrade2$tariff*2+3
@ 

If we tried to impute this dataset, \Amelia\ could draw imputations without
any problems:

<<>>=
a.out.bad <- amelia(freetrade2, ts = "year", cs = "country")
a.out.bad
@ 

But if we were to run \code{disperse}, we would end up with the
problematic figure \ref{f:overbad}:

<<dispbad, include=FALSE>>=
disperse(a.out.bad, dims = 1, m = 5)
@ 

While this is a special case of a problematic likelihood, situations very
similar to this can go undetected without using the proper diagnostics.
More generally, an unidentified imputation model will lead to non-unique
ML estimates (see \citet{King89} for a more detailed discussion of
identification and likelihoods).


<<echo=FALSE, results = hide>>=
options(SweaveHooks = list(fig = function() par(mfrow=c(1,1))))
@ 
\begin{figure}
  \begin{center} 
<<dispbadfig, echo=FALSE, fig=TRUE, width = 7, height = 7>>=
<<dispbad>>
@
\label{f:overbad}
  \caption{ A problematic plot from the overdispersion diagnostic
    showing that EM chains are converging to one of two different
    modes, depending upon the starting value of the chain.}
  \end{center}
\end{figure}


\subsubsection{Time-series plots}
\label{sec:tscsplots}

As discussed above, information about time trends and fixed effects can
help produce better imputations. One way to check the plausibility of our
imputation model is to see how it predicts missing values in a time
series. If the imputations for the Malaysian tariff rate were drastically
higher in 1990 than the observed years of 1989 or 1991, we might worry
that there is a problem in our imputation model. Checking these time
series is easy to do with the \code{tscsPlot} command. Simply choose the
variable (with the \code{var} argument) and the cross-section (with the
\code{cs} argument) to plot the observed time-series along with
distributions of the imputed values for each missing time period. For
instance, we can run

<<tsplot1, include=FALSE>>=
tscsPlot(a.out.time, cs = "Malaysia", main = "Malaysia (with time settings)", 
         var = "tariff", ylim = c(-10, 60))
@

\begin{figure}
  \begin{center} 
<<tsplot2, echo=FALSE, fig=TRUE, width = 7, height = 7>>=
<<tsplot1>>
@
\label{fig:tsplot1}
  \caption{Tariff rates in Malaysia, 1980-2000. An example of the
    \texttt{tscsPlot} function, the black points are observed values of
    the time series and the red points are the mean of the imputation
    distributions. The red lines represent the 95\% confidence bands of
    the imputation distribution.}
  \end{center}
\end{figure}

to get the plot in figure \ref{fig:tsplot1}. Here, the black point are
observed tariff rates for Malaysia from 1980 to 2000. The red points are
the mean imputation for each of the missing values, along with their 95\%
confidence bands. We draw these bands by imputing each of missing values
100 times to get the imputation distribution for that observation. 

In figure \ref{fig:tsplot1}, we can see that the imputed 1990 tariff rate
is quite in line with the values around it. Notice also that values toward
the beginning and end of the time series have higher imputation variance.
This occurs because the fit of the polynomials of time in the imputation
model have higher variance at the beginning and end of the time
series. This is intuitive because these points have fewer neighbors from
which to draw predictive power. 

A word of caution is in order. As with comparing the histograms of imputed
and obseved values, there could be reasons that the missing values are
systematically different than the observed time series. For instance, if
there had been a major financial crisis in Malaysia in 1990 which caused
the government to close off trade, then we would expect that the missing
tariff rates should be quite different than the observed time series. If
we have this information in our imputation model, we might expect to see
out-of-line imputations in these time-series plots. If, on the other hand,
we did not have this information, we might see ``good'' time-series plots
that fail to point out this violation of the MAR assumption. Our
imputation model would produce poor estimates of the missing values since
it would be unaware that both the missingness and the true unobserved
tariff rate depend on another variable. Hence, the \code{tscsPlot} is
useful for finding obvious problems in imputation model and comparing the
efficiency of various imputation models, but it cannot speak to the
untestable assumption of MAR.

\subsubsection{Missingness maps}
\label{sec:missmaps}

One useful tool for exploring the missingness in a dataset is a
\emph{missingness map}. This is a map that visualizes the dataset a grid
and colors the grid by missingness status. The column of the grid are the
variables and the rows are the observations, as in any spreadsheet
program. This tool allows for a quick summary of the patterns of
missingness in the data. 

If we simply call the \code{missmap} function on our output from
\code{amelia},
<<mmap1, include=FALSE>>=
missmap(a.out) 
@ 
we get the plot in figure \ref{fig:missmap}. The \code{missmap} function
arrange the columns so that the variables are in decreasing order of
missingness from left to right. If the \code{cs} argument was set in the
\code{amelia} function, the labels for the rows will indicate where each
of the cross-sections begin. 


\begin{figure}
  \begin{center} 
<<mmap2, echo=FALSE, fig=TRUE, width = 7, height = 7>>=
<<mmap1>>
@
\label{fig:missmap}
  \caption{Missingness map of the \texttt{freetrade} data. Missing values
    are in tan and observed values are in red.}
  \end{center}
\end{figure}

In figure \ref{fig:missmap}, it is clear that the tariff rate is the
variable most missing in the data and it tends to be missing in blocks of
a few observations.  Gross international reserves (\code{intresmi}) and
financial openness (\code{fivop}), on the other hand, are missing mostly
at the end of each cross-section. This suggests \emph{missingness by
  merging}, when variables with different temporal coverages are merged to
make one dataset. Sometimes this kind of missingness is an artifact of the
date at which the data was merged and researchers can resolve it by
finding updated versions of the relevant variables.

The missingness map is an important tool for understanding the patterns of
missingness in the data and can often indicate potential ways to improve
the imputation model or data collection process. 


\subsection{Analysis Models}
\label{sec:analysis}

Imputation is most often a data processing step as opposed to a final
model in of itself. To this end, it is easy to to pass output from
\code{amelia} to other functions. The easiest and most integrated way to
run an analysis model is to pass the output to the \code{zelig} function
from the \code{Zelig} package. For example, in \citet{MilKub05}, the
dependent variable was tariff rates. We can replicate table 5.1 from their
analysis with the original data simply by running

<<results = hide>>=
require(Zelig)
z.out <- zelig(tariff ~ polity + pop + gdp.pc + year +country, data = freetrade, model = "ls")
@ 

<<>>=
summary(z.out)
@ 

Running the same model with imputed data is almost identical. Simply
replace the original data set with the imputations from the \code{amelia}
output:


<<>>=
z.out.imp <- zelig(tariff ~ polity + pop + gdp.pc + year +country, data =
                   a.out$imputations, model = "ls")
@ 

<<>>= 
summary(z.out.imp)
@ 


Zelig is one way to run analysis models on imputed data, but certainly not
the only way. The \code{imputations} list in the \code{amelia} output
contains each of the imputed datasets. Thus, users could simply program a
loop over the number of imputations and run the analysis model on each
imputed dataset and combine the results using the rules described in
\citet{KinHonJos01} and \citet{Schafer97}. Furthermore, users can easily
export their imputations using the \code{write.amelia} function as
described in \ref{sec:saving} and use statistical packages other than {\sf
  R} for the analysis model. 

%% add example loop here?

\clearpage


\section{\AmeliaView\ Menu Guide}
\label{sec:menu}
Below is a guide to the \AmeliaView\ menus with references back to the
users's guide. The same principles from the user's guide apply to
\AmeliaView. The only difference is how you interact with the program.
Whether you use the GUI or the command line versions, the same
underlying code is being called, and so you can read the command
line-oriented versions of this manual even if you intend to use the
GUI.

\subsection{Loading \AmeliaView}

The easiest way to load \AmeliaView\ is to open an \R\ session and type
the following two commands:
\begin{verbatim}
> library(Amelia)
> AmeliaView()
\end{verbatim}
This will bring up the \AmeliaView\ window on any platform. 

On the Windows operating system, there is an alternative way to start
\AmeliaView\ from the Desktop. See section \ref{sec:win-install} for a
guide on how to install this version. Once installed, there should be a
Desktop icon for \AmeliaView. Simply double-click this icon and the
\AmeliaView\ window should appear. If, for some reason, this approach does
not work, simply open an \R\ session and use the approach above.

\subsection{Step 1 - Input}
\label{sec:step1}
\begin{figure}[ht]
  \centering 
    \includegraphics[scale=1]{step1.pdf}
  \caption{Detail for step 1 on the front page of \AmeliaView.}
\end{figure}
\begin{enumerate}
\item \textbf{Input Data Format} - Choose the format for your dataset.
  The format you pick will be the default format that is shown when
  you open the ``Browse'' dialog.  Currently,\Amelia\ 
  supports five different file formats: Comma-Separated Values (.CSV),
  Tab-Delimited Text (.TXT), Stata v.5-8 (.DTA), SPSS (.DAT), and SAS
  Transport (.XPORT).
\item \textbf{Input Data File} - Enter the location of your dataset.
  If your file is located in a high level directory, it might be
  you are trying to access for more information.
\item \textbf{Browse} - Find files on the system. 
\item \textbf{Load Data} - Loads the data in the ``Input Data File''
  line. Once the file is loaded, you can reload a different file, but you
  will lose any work on currently loaded file.
\item \textbf{Summarize Data} - View plots and summary statistics for
  the individual variables.  This button will bring up a dialog box
  with a list of variables.  Clicking on each variable will display
  the summary statistics on the right.  Below these statistics, there
  is a ``Plot Variable'' button, which will show a histogram of the
  variable.  For data that are string or character based, \AmeliaView\
  will not show summary statistics or plot histograms.
\end{enumerate}


\subsection{Step 2 - Options}

\label{sec:step2}
\begin{figure}[ht]
  \centering
    \includegraphics[scale=1]{step2.pdf}
  \caption{Detail for step 2 on the front page of \AmeliaView.}
\end{figure}
\begin{enumerate}
\item \textbf{Time Series Variable} - Choose the variable that indexes
  time in the dataset.  If there is no time series component in your
  data, set it to ``(none).''  You must set this option in order to
  access the Time Series Cross Sectional options dialog.
\item \textbf{Cross Sectional Variable} - Choose the variable that
  indexes the cross-section.  You must set this in order to access the
  ``Set Case Priors'' in the ``Priors'' dialog.
\item \textbf{Variables} - Becomes available after you load the data.
  See \ref{sec:vardiag} for more information.
\item \textbf{TSCS} - Becomes available after you set the Time Series
  variable.  See \ref{sec:tscsdiag} for more information.
\item \textbf{Priors} - Becomes available after you load the data.
  See \ref{sec:pridiag} for more information.
\end{enumerate}

\subsubsection{Variables Dialog}
\label{sec:vardiag}
\begin{figure}[ht]
  \centering 
    \includegraphics[scale=1]{varopts.pdf}
  \caption{Detail for Variable Options dialog.}
\end{figure}
\begin{enumerate}
\item \textbf{Variable Transformations} - Choose the transformation
  that best tailors the variable to the multivariate normal, if appropriate.  See \ref{sec:trans} on Transformations to see how each transformation is
  useful.  You can also choose whether or not the variable is an identification (ID) variable.  If so, it will be left out of the imputation model, but
  will remain in the imputed datasets.  This is useful for variables that have
  no explanatory power like extra case identifiers.
\item \textbf{Tolerance} - Adjust the level of tolerance that \Amelia\ 
  uses to check convergence of the EM algorithm.  In very large datasets, if your imputation chains run a long time without converging, increasing the tolerance will allow a lower threshold to judge convergence and end chains after fewer iterations. 
\end{enumerate}


\subsubsection{Time Series Cross Sectional Dialog}
\label{sec:tscsdiag}
\begin{figure}[ht]
  \centering 
    \includegraphics[scale=1]{tscs.pdf}
  \caption{Detail for Time-Series-Cross-Section Options dialog.}
\end{figure}
\begin{enumerate}
\item \textbf{Polynomials of Time} - This option, if activated, will
  have \Amelia\ use trends of time as a additional
  condition for fitting the missing data.  The higher the level of
  polynomial will allow more variation in the trend structure, yet it
  will take more degrees of freedom to estimate.
\item \textbf{Interact with Cross-Section} - Interacting this with the
  cross section is way of allowing the trend of time to vary across
  cases as well.  Using a 0 level polynomial and interacting with the
  cross section is the equivalent of using a fixed effects.  For more
  information see \ref{sec:tscs} above.
\item \textbf{Variable Listbox} - Choose the variables whose lag or lead you
  would like to include in the imputation model. 
\item \textbf{Lag Settings} - Choose to include lags and leads in the
  data set to handle the effects of time.  See \ref{sec:lags} above.
\end{enumerate}

\subsubsection{Priors Dialog}
\label{sec:pridiag}
\begin{figure}[ht]
  \centering
   \includegraphics[scale=1]{priors.pdf}
  \caption{Detail for Priors Options dialog.}
\end{figure}
\begin{enumerate}
\item \textbf{Empirical Prior} - A prior that adds observations to
  your data in order to shrink the covariances.  A useful place to
  start is around 0.5\% of the total number of observations in the
  dataset (see \ref{sec:prior}).
\item \textbf{Set Observational Priors} - Set prior beliefs about 
 ranges for individual missing observations.  For more information 
 about observational priors, see \ref{sec:obspri}.
\end{enumerate}


\subsubsection{Observational Priors}\label{sec:refobspri}
\begin{figure}[h]
  \centering
    \includegraphics[scale=1]{obsprior.pdf}
  \caption{Detail for Observational Priors dialog}
\end{figure}
\begin{enumerate}
\item \textbf{Current Priors} - A list of current priors in distributional
  form, with the variable and case name.  
\item \textbf{Add Distributional Prior} - Add a prior belief about an
  observation or an entire variable with a mean and standard deviation about the
  missing values.  
\item \textbf{Add Range Prior} - Add a prior belief about an observation or an
  entire variable with a range and a confidence level.  
\item \textbf{Remove Selected Priors} - This will remove any of the current
  priors selected with the check box.  
\end{enumerate}

\subsubsection{Add Distribution Prior}\label{sec:refdistpri}
\begin{figure}[h]
  \centering
    \includegraphics[width=3.39in, height=2.31in]{distpri.pdf}
  \caption{Detail for Add Distributional Prior dialog}
\end{figure}
\begin{enumerate}
\item \textbf{Case} - Select the case name or number you wish to set the prior
  about.  You can also choose to make the prior for the entire variable.  The
  case names are generated from the row name of the observation, the value of the
  cross-section variable of the observation and the value of the time series
  variable of the observation.  
\item \textbf{Variable} - The variable associated with the prior you would like
  specify.  The list provided only shows the missing variables for the currently
  selected observation.  
\item \textbf{Mean} - The mean value of the prior. The textbox will not accept
  letters or out of place punctuation.
\item \textbf{Standard Deviation} - The standard deviation of the prior.  The
  textbox will only accept positive non-zero values.  
\end{enumerate}


\subsubsection{Add Range Prior}\label{sec:refrangepri}
\begin{figure}[h]
  \centering 
    \includegraphics[height = 2.69in,width=2.86in]{rangepri.pdf}
  \caption{Detail for Add Range Prior dialog}
\end{figure}
\begin{enumerate}
\item \textbf{Case} - Select the case name or number you wish to set the prior
  about.  You can also choose to make the prior for the entire variable.  The
  case names are generated from the row name of the observation, the value of the
  cross-section variable of the observation and the value of the time series
  variable of the observation.  
\item \textbf{Variable} - The variable associated with the prior you would like
  specify.  The list provided only shows the missing variables for the currently
  selected observation.  
\item \textbf{Minimum} - The minimum value of the prior. The textbox will not accept
  letters or out of place punctuation.
\item \textbf{Maximum} - The maximum value of the prior. The textbox will not accept
  letters or out of place punctuation.
\item \textbf{Confidence} - The confidence level of the prior.  This should be
  between 0 and 1, non-inclusive.  This value represents how certain your priors
  are.  This value cannot be 1, even if you are absolutely certain of a give
  range.  This is used to convert the range into an appropriate distributional
  prior.  
\end{enumerate}


\subsection{Step 3 - Output}
\label{sec:step3}


\begin{figure}[ht]
  \centering 
    \includegraphics[scale=1]{step3.pdf}
  \caption{Detail for step 3 on the front page of AmeliaView.}
\end{figure}
\begin{enumerate}
\item \textbf{Output Data Format} - Choose the format of output data.
  If you would like to not save any output data sets (if you wanted,
  for instance, to simply look at diagnostics), set this option to
  ``(no save).''  Currently, you can save the output data as: Comma
  Separated Values (.CSV), Tab Delimited Text (.TXT), Stata (.DTA), R save
  object (.RData), or to hold it in \R\ memory. This last option will only
  work if you have called \AmeliaView\ from an \R\ session and want to
  return to the \R\ command line to work with the output. It will have the
  name in memory from ``Name of Imputed Datasets''.
\item \textbf{Name of Imputed Datasets} - Enter the prefix for the
  output data files.  If you set this to ``mydata'', your output files
  will be \texttt{mydata1.csv, mydata2.csv...} etc.  Try to keep this
  name short as some operating systems have a difficult time reading
  long filenames.
\item \textbf{Number of Imputed Datasets} - Set the number of
  imputations you would like.  In most cases, 5 will be enough to make
  accurate predictions about the means and variances.  
\item \textbf{Seed} - Sets the seed for the random number generator used
  by \Amelia. Useful if you need to have the same output twice. 
\item \textbf{Run Amelia} - Runs the \Amelia\ procedure on
  the input data.  A dialog will open marking the progress of
  \Amelia.  Once it is finished, it will tell you that
  you can close the dialog.  If an error message appears, follow its
  instructions; this usually involves closing the dialog, resetting
  the options, and running the procedure again.
\item \textbf{Diagnostics} - Post-imputation diagnostics.  The only
  currently available graph compares the densities of the observed
  data to the mean imputation across the $m$ imputed datasets.
\end{enumerate}


\subsubsection{Diagnostics Dialog}
\label{sec:diagdiag}
\begin{figure}[ht]
  \centering
    \includegraphics[scale=1]{diag.pdf}
  \caption{Detail for Diagnostics dialog.}
\end{figure}
\begin{enumerate}
\item \textbf{Compare Plots} - This will display the relative
  densities of the observed (red) and imputed (black) data.  The
  density of the imputed values are the average imputations across all
  of the imputed datasets.
\item \textbf{Overimpute} - This will run \Amelia\ on the full data
  with one cell of the chosen variable artificially set to missing and
  then check the result of that imputation against the truth.  The
  resulting plot will plot average imputations against true values
  along with 90\% confidence intervals.  These are plotted over a
  $y=x$ line for visual inspection of the imputation model.
\item \textbf{Number of overdispersions} - When running the
  overdispersion diagnostic, you need to run the imputation algorithm
  from several overdispersed starting points in order to get a clear
  idea of how the chain are converging.  Enter the number of
  imputations here.
\item \textbf{Number of dimensions} - The overdispersion diagnostic
  must reduce the dimensionality of the paths of the imputation
  algorithm to either one or two dimensions due to graphical
  restraints.
\item \textbf{Overdisperse} - Run overdispersion diagnostic to
  visually inspect the convergence of the \Amelia\ algorithm from
  multiple start values that are drawn randomly.
\end{enumerate}

\clearpage

\section{Reference to Amelia's Functions}

\include{Rd/africa}
\include{Rd/amelia}
\include{Rd/compare.density}
\include{Rd/disperse}
\include{Rd/freetrade}
\include{Rd/missmap}
\include{Rd/overimpute}
\include{Rd/plot.amelia}
\include{Rd/summary.amelia}
\include{Rd/tscsPlot}
\include{Rd/write.amelia}

\bibliographystyle{apsr}
\bibsep=0in
\bibliography{gk.bib,gkpubs.bib}
\end{document}

